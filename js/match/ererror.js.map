{"version":3,"sources":["../src/match/ererror.ts"],"names":[],"mappings":";AAAA;;;;;;;GAOG;;AAKH,6BAA+B;AAE/B,IAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;AACjC,IAAM,SAAS,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;AAClC,IAAM,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;AAI9B,IAAM,SAAS,GAAQ,MAAM,CAAC;AAK9B,sDAAsD;AACtD,mCAAqC;AAErC,SAAgB,uBAAuB,CAAC,KAAc,EAAE,MAAiB;IACrE,IAAG,KAAK,GAAG,CAAC,IAAI,KAAK,IAAI,MAAM,CAAC,MAAM,EAAE;QACtC,MAAM,KAAK,CAAC,sCAAsC,GAAG,KAAK,GAAG,eAAe,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;KAC/F;IACH,OAAO;QACL,QAAQ,EAAE,MAAM,CAAC,iBAAiB;QAClC,IAAI,EAAG,2BAAwB,MAAM,CAAC,KAAK,CAAC,QAAI;QAChD,OAAO,EAAG;YACR,MAAM,EAAE,MAAM;YACd,KAAK,EAAG,MAAM,CAAC,KAAK,CAAC;YACrB,KAAK,EAAG,KAAK;SACd;KAC8B,CAAC;AACpC,CAAC;AAbD,0DAaC;AAGD,SAAgB,qBAAqB;IACnC,OAAO;QACL,QAAQ,EAAE,MAAM,CAAC,eAAe;QAChC,IAAI,EAAG,yBAAyB;KACd,CAAC;AACvB,CAAC;AALD,sDAKC;AAED,SAAgB,YAAY,CAAC,MAA0B;IACrD,IAAG,MAAM,CAAC,MAAM,EAAE;QAChB,OAAO,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,IAAI,EAAR,CAAQ,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KACtD;IACD,OAAO;AACT,CAAC;AALD,oCAKC","file":"ererror.js","sourcesContent":["/**\n *\n * @module jfseb.fdevstart.analyze\n * @file erbase\n * @copyright (c) 2016 Gerd Forstmann\n *\n * Basic domain based entity recognition\n */\n\n\nimport * as InputFilter from './inputFilter';\n\nimport * as debug from 'debug';\n\nconst debuglog = debug('erbase');\nconst debuglogV = debug('erbase');\nconst perflog = debug('perf');\n\nimport { BreakDown  as breakdown } from 'mgnlq_model';\n\nconst AnyObject = <any>Object;\n\n\nimport * as utils from 'abot_utils';\n\n//import { IFModel as IFModel} from 'fdevsta_monmove';\nimport * as IMatch from './iferbase';\n\nexport function makeError_NO_KNOWN_WORD(index : number, tokens : string[]) :IMatch.IERErrorNO_KNOWN_WORD {\n    if(index < 0 || index >= tokens.length) {\n      throw Error(\"invalid index in Error construction \" + index + \"tokens.lenth=\" + tokens.length);\n    }\n  return {\n    err_code: IMatch.ERR_NO_KNOWN_WORD,\n    text : `I do not understand \"${tokens[index]}\".`,\n    context : {\n      tokens: tokens,\n      token : tokens[index],\n      index : index\n    }\n  } as IMatch.IERErrorNO_KNOWN_WORD;\n}\n\n\nexport function makeError_EMPTY_INPUT( ) :IMatch.IERError {\n  return {\n    err_code: IMatch.ERR_EMPTY_INPUT,\n    text : `I did not get an input.`,\n  } as IMatch.IERError;\n}\n\nexport function explainError(errors : IMatch.IERError[]) {\n  if(errors.length) {\n    return \"\\n\" + errors.map(err => err.text).join(\"\\n\");\n  }\n  return;\n}"]}