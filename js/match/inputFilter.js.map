{"version":3,"sources":["../src/match/inputFilter.ts"],"names":[],"mappings":"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","file":"match/inputFilter.js","sourcesContent":["/**\r\n * the input filter stage preprocesses a current context\r\n *\r\n * It a) combines multi-segment arguments into one context members\r\n * It b) attempts to augment the context by additional qualifications\r\n *           (Mid term generating Alternatives, e.g.\r\n *                 ClientSideTargetResolution -> unit test?\r\n *                 ClientSideTargetResolution -> source ?\r\n *           )\r\n *  Simple rules like  Intent\r\n *\r\n *\r\n * @module jfseb.fdevstart.inputFilter\r\n * @file inputFilter.ts\r\n * @copyright (c) 2016 Gerd Forstmann\r\n */\r\n// <reference path=\"../../lib/node-4.d.ts\" />\r\nimport * as distance from 'abot_stringdist';\r\n\r\n//import * as Logger from '../utils/logger';\r\n\r\n//const logger = Logger.logger('inputFilter');\r\n\r\nimport * as debug from 'debugf';\r\nvar debugperf = debug('perf');\r\nvar logger = debug('inputFilterLogger');\r\n\r\nimport {IFModel as IFModel} from 'mgnlq_model';\r\nimport * as utils from 'abot_utils';\r\n\r\n//import * as IFMatch from '../match/iferbase';\r\n\r\n\r\n//import * as inputFilterRules from './inputFilterRules';\r\n\r\nimport * as Algol from './algol';\r\n\r\nimport * as IFMatch from './iferbase';\r\nimport * as IMatch from './iferbase';\r\n\r\nimport { BreakDown as breakdown} from 'mgnlq_model';\r\n\r\nconst AnyObject = <any>Object;\r\n\r\nvar debuglog = debug('inputFilter')\r\nvar debuglogV = debug('inputVFilter')\r\nvar debuglogM = debug('inputMFilter')\r\n\r\nexport function mockDebug(o) {\r\n  debuglog = o;\r\n  debuglogV = o;\r\n  debuglogM = o;\r\n}\r\n\r\n\r\n/**\r\n * @param sText {string} the text to match to NavTargetResolution\r\n * @param sText2 {string} the query text, e.g. NavTarget\r\n *\r\n * @return the distance, note that is is *not* symmetric!\r\n */\r\nexport function calcDistance(sText1: string, sText2: string): number {\r\n  return distance.calcDistanceAdjusted(sText1,sText2);\r\n}\r\n\r\n\r\nexport interface ICntRec {\r\n};\r\n\r\n\r\ntype IRule = IFMatch.IRule\r\n\r\n\r\nexport interface IMatchOptions {\r\n  matchothers?: boolean,\r\n  augment?: boolean,\r\n  override?: boolean\r\n}\r\n\r\ninterface IMatchCount {\r\n  equal: number\r\n  different: number\r\n  spuriousR: number\r\n  spuriousL: number\r\n}\r\n\r\ntype EnumRuleType = IFModel.EnumRuleType\r\n\r\nexport function levenPenalty(i: number): number {\r\n  // 1 -> 1\r\n  // cutOff => 0.8\r\n  return i;\r\n  //return   1 -  (1 - i) *0.2/Algol.Cutoff_WordMatch;\r\n}\r\n\r\n\r\nfunction nonPrivateKeys(oA) {\r\n  return Object.keys(oA).filter(key => {\r\n    return key[0] !== '_';\r\n  });\r\n}\r\n\r\nexport function countAinB(oA, oB, fnCompare, aKeyIgnore?): number {\r\n  aKeyIgnore = Array.isArray(aKeyIgnore) ? aKeyIgnore :\r\n    typeof aKeyIgnore === \"string\" ? [aKeyIgnore] : [];\r\n  fnCompare = fnCompare || function () { return true; }\r\n  return nonPrivateKeys(oA).filter(function (key) {\r\n    return aKeyIgnore.indexOf(key) < 0;\r\n  }).\r\n    reduce(function (prev, key) {\r\n      if (Object.prototype.hasOwnProperty.call(oB, key)) {\r\n        prev = prev + (fnCompare(oA[key], oB[key], key) ? 1 : 0)\r\n      }\r\n      return prev\r\n    }, 0)\r\n}\r\n\r\nexport function spuriousAnotInB(oA, oB, aKeyIgnore?) {\r\n  aKeyIgnore = Array.isArray(aKeyIgnore) ? aKeyIgnore :\r\n    typeof aKeyIgnore === \"string\" ? [aKeyIgnore] : [];\r\n  return nonPrivateKeys(oA).filter(function (key) {\r\n    return aKeyIgnore.indexOf(key) < 0;\r\n  }).\r\n    reduce(function (prev, key) {\r\n      if (!Object.prototype.hasOwnProperty.call(oB, key)) {\r\n        prev = prev + 1\r\n      }\r\n      return prev\r\n    }, 0)\r\n}\r\n\r\nfunction lowerCase(o) {\r\n  if (typeof o === \"string\") {\r\n    return o.toLowerCase()\r\n  }\r\n  return o\r\n}\r\n\r\nexport function compareContext(oA, oB, aKeyIgnore?) {\r\n  var equal = countAinB(oA, oB, function (a, b) { return lowerCase(a) === lowerCase(b); }, aKeyIgnore);\r\n  var different = countAinB(oA, oB, function (a, b) { return lowerCase(a) !== lowerCase(b); }, aKeyIgnore);\r\n  var spuriousL = spuriousAnotInB(oA, oB, aKeyIgnore)\r\n  var spuriousR = spuriousAnotInB(oB, oA, aKeyIgnore)\r\n  return {\r\n    equal: equal,\r\n    different: different,\r\n    spuriousL: spuriousL,\r\n    spuriousR: spuriousR\r\n  }\r\n}\r\n\r\nfunction sortByRank(a: IFMatch.ICategorizedString, b: IFMatch.ICategorizedString): number {\r\n  var r = -((a._ranking || 1.0) - (b._ranking || 1.0));\r\n  if (r) {\r\n    return r;\r\n  }\r\n  if (a.category && b.category) {\r\n    r = a.category.localeCompare(b.category);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  if (a.matchedString && b.matchedString) {\r\n    r = a.matchedString.localeCompare(b.matchedString);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction cmpByRank(a: IFMatch.ICategorizedString, b: IFMatch.ICategorizedString): number {\r\n  return sortByRank(a,b);\r\n}\r\n\r\n\r\nfunction sortByRankThenResult(a: IFMatch.ICategorizedStringRanged, b: IFMatch.ICategorizedStringRanged): number {\r\n  var r = -((a._ranking || 1.0) - (b._ranking || 1.0));\r\n  if (r) {\r\n    return r;\r\n  }\r\n  if (a.category && b.category) {\r\n    r = a.category.localeCompare(b.category);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  if (a.matchedString && b.matchedString) {\r\n    r = a.matchedString.localeCompare(b.matchedString);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  r = cmpByResultThenRank(a,b);\r\n  if(r) {\r\n    return r;\r\n  }\r\n  return 0;\r\n}\r\n\r\n\r\nexport function cmpByResult(a: IFMatch.ICategorizedStringRanged, b: IFMatch.ICategorizedStringRanged): number {\r\n  if(a.rule === b.rule) {\r\n    return 0;\r\n  }\r\n  var r = a.rule.bitindex - b.rule.bitindex;\r\n  if(r) {\r\n    return r;\r\n  }\r\n  if (a.rule.matchedString && b.rule.matchedString) {\r\n    r = a.rule.matchedString.localeCompare(b.rule.matchedString);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  if (a.rule.category && b.rule.category) {\r\n    r = a.rule.category.localeCompare(b.rule.category);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  if (a.rule.wordType && b.rule.wordType) {\r\n    r = a.rule.wordType.localeCompare(b.rule.wordType);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n\r\n\r\nexport function cmpByResultThenRank(a: IFMatch.ICategorizedStringRanged, b: IFMatch.ICategorizedStringRanged): number {\r\n  var r = cmpByResult(a,b);\r\n  if (r) {\r\n    return r;\r\n  }\r\n  var r = -((a._ranking || 1.0) - (b._ranking || 1.0));\r\n  if (r) {\r\n    return r;\r\n  }\r\n  // TODO consider a tiebreaker here\r\n  return 0;\r\n}\r\n\r\nfunction analyseRegexp(\r\n  res : Array<IFMatch.ICategorizedString>,\r\n  oRule : IFModel.mRule,\r\n  string : string )\r\n{\r\n  debuglog(()=> \" here regexp: \" + JSON.stringify(oRule, undefined, 2) + '\\n' + oRule.regexp.toString() );\r\n  var m = oRule.regexp.exec(string);\r\n  var rec = undefined;\r\n  if (m) {\r\n    rec = {\r\n      string: string,\r\n      matchedString: (oRule.matchIndex !== undefined && m[oRule.matchIndex]) || string,\r\n      rule : oRule,\r\n      category: oRule.category,\r\n      _ranking: oRule._ranking || 1.0\r\n    };\r\n    debuglog(()=>\"\\n!match regexp  \" + oRule.regexp.toString() + \" \" + rec._ranking.toFixed(3) + \"  \" + string + \"=\"  + oRule.lowercaseword  + \" => \" + oRule.matchedString + \"/\" + oRule.category);\r\n    res.push(rec);\r\n  }\r\n}\r\n\r\n\r\nexport function checkOneRule(string: string, lcString : string, exact : boolean,\r\nres : Array<IFMatch.ICategorizedString>,\r\noRule : IFModel.mRule, cntRec? : ICntRec ) {\r\n    debuglogV(()=> 'attempting to match rule ' + JSON.stringify(oRule) + \" to string \\\"\" + string + \"\\\"\");\r\n    switch (oRule.type) {\r\n      case IFModel.EnumRuleType.WORD:\r\n        if(!oRule.lowercaseword) {\r\n          throw new Error('rule without a lowercase variant' + JSON.stringify(oRule, undefined, 2));\r\n         };\r\n         // TODO CHECK THIS\r\n        if (exact && (oRule.word === string || oRule.lowercaseword === lcString)) {\r\n  //      if (exact && oRule.word === string || oRule.lowercaseword === lcString) {\r\n          debuglog(()=>\"\\n!matched exact \" + string + \"=\"  + oRule.lowercaseword  + \" => \" + oRule.matchedString + \"/\" + oRule.category);\r\n          res.push({\r\n            string: string,\r\n            matchedString: oRule.matchedString,\r\n            category: oRule.category,\r\n            _ranking: oRule._ranking || 1.0\r\n          })\r\n        }\r\n        if (!exact && !oRule.exactOnly) {\r\n          var levenmatch = calcDistance(oRule.lowercaseword, lcString);\r\n\r\n/*\r\n          addCntRec(cntRec,\"calcDistance\", 1);\r\n          if(levenmatch < 50) {\r\n            addCntRec(cntRec,\"calcDistanceExp\", 1);\r\n          }\r\n          if(levenmatch < 40000) {\r\n            addCntRec(cntRec,\"calcDistanceBelow40k\", 1);\r\n          }\r\n          */\r\n          //if(oRule.lowercaseword === \"cosmos\") {\r\n          //  console.log(\"here ranking \" + levenmatch + \" \" + oRule.lowercaseword + \" \" + lcString);\r\n          //}\r\n          if (levenmatch >= Algol.Cutoff_WordMatch) { // levenCutoff) {\r\n            addCntRec(cntRec,\"calcDistanceOk\", 1);\r\n            var rec = {\r\n              string: string,\r\n              matchedString: oRule.matchedString,\r\n              category: oRule.category,\r\n              _ranking: (oRule._ranking || 1.0) * levenPenalty(levenmatch),\r\n              levenmatch: levenmatch\r\n            };\r\n            debuglog(()=>\"\\n!fuzzy \" + (levenmatch).toFixed(3) + \" \" + rec._ranking.toFixed(3) + \"  \" + string + \"=\"  + oRule.lowercaseword  + \" => \" + oRule.matchedString + \"/\" + oRule.category);\r\n            res.push(rec);\r\n          }\r\n        }\r\n        break;\r\n      case IFModel.EnumRuleType.REGEXP: {\r\n        analyseRegexp( res, oRule, string );\r\n        break; // throw Error('REGEXP not supported');\r\n      }\r\n      //break;\r\n      default:\r\n        throw new Error(\"unknown type\" + JSON.stringify(oRule, undefined, 2))\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function checkOneRuleWithOffset(string: string, lcString : string, exact : boolean,\r\nres : Array<IMatch.ICategorizedStringRanged>,\r\noRule : IFModel.mRule, cntRec? : ICntRec ) {\r\n    debuglogV(()=>'attempting to match rule ' + JSON.stringify(oRule) + \" to string \\\"\" + string + \"\\\"\");\r\n    switch (oRule.type) {\r\n      case IFModel.EnumRuleType.WORD:\r\n        if(!oRule.lowercaseword) {\r\n          throw new Error('rule without a lowercase variant' + JSON.stringify(oRule, undefined, 2));\r\n         };\r\n        if (exact && (oRule.word === string || oRule.lowercaseword === lcString)) {\r\n          debuglog(()=> \"\\n!matched exact \" + string + \"=\"  + oRule.lowercaseword  + \" => \" + oRule.matchedString + \"/\" + oRule.category);\r\n          res.push({\r\n            string: string,\r\n            matchedString: oRule.matchedString,\r\n            category: oRule.category,\r\n            rule: oRule,\r\n            _ranking: oRule._ranking || 1.0\r\n          })\r\n        }\r\n        if (!exact && !oRule.exactOnly) {\r\n          var levenmatch = calcDistance(oRule.lowercaseword, lcString);\r\n\r\n/*\r\n          addCntRec(cntRec,\"calcDistance\", 1);\r\n          if(levenmatch < 50) {\r\n            addCntRec(cntRec,\"calcDistanceExp\", 1);\r\n          }\r\n          if(levenmatch < 40000) {\r\n            addCntRec(cntRec,\"calcDistanceBelow40k\", 1);\r\n          }\r\n          */\r\n          //if(oRule.lowercaseword === \"cosmos\") {\r\n          //  console.log(\"here ranking \" + levenmatch + \" \" + oRule.lowercaseword + \" \" + lcString);\r\n          //}\r\n          if (levenmatch >= Algol.Cutoff_WordMatch) { // levenCutoff) {\r\n            //console.log(\"found rec\");\r\n            addCntRec(cntRec,\"calcDistanceOk\", 1);\r\n            var rec = {\r\n              string: string,\r\n              rule : oRule,\r\n              matchedString: oRule.matchedString,\r\n              category: oRule.category,\r\n              _ranking: (oRule._ranking || 1.0) * levenPenalty(levenmatch),\r\n              levenmatch: levenmatch\r\n            };\r\n            debuglog(() =>\"\\n!CORO: fuzzy \" + (levenmatch).toFixed(3) + \" \" + rec._ranking.toFixed(3) + \"  \\\"\" + string + \"\\\"=\"  + oRule.lowercaseword  + \" => \" + oRule.matchedString + \"/\" + oRule.category + \"/\" + oRule.bitindex);\r\n            res.push(rec);\r\n          }\r\n        }\r\n        break;\r\n      case IFModel.EnumRuleType.REGEXP: {\r\n        analyseRegexp( res, oRule, string );\r\n        break;\r\n      }\r\n      //break;\r\n      default:\r\n        throw new Error(\"unknown type\" + JSON.stringify(oRule, undefined, 2))\r\n    }\r\n}\r\n\r\n\r\nfunction addCntRec(cntRec : ICntRec, member : string, number : number) {\r\n  if((!cntRec) || (number === 0)) {\r\n    return;\r\n  }\r\n  cntRec[member] = (cntRec[member] || 0) + number;\r\n}\r\n\r\n/*\r\nexport function categorizeString(word: string, exact: boolean, oRules: Array<IFModel.mRule>,\r\n cntRec? : ICntRec): Array<IFMatch.ICategorizedString> {\r\n  // simply apply all rules\r\n  debuglogV(() => \"rules : \" + JSON.stringify(oRules, undefined, 2));\r\n\r\n  var lcString = word.toLowerCase();\r\n  var res: Array<IFMatch.ICategorizedString> = []\r\n  oRules.forEach(function (oRule) {\r\n    checkOneRule(word,lcString,exact,res,oRule,cntRec);\r\n  });\r\n  res.sort(sortByRank);\r\n  return res;\r\n}\r\n*/\r\n\r\n\r\n\r\nexport function categorizeSingleWordWithOffset(word: string, lcword : string, exact: boolean, oRules: Array<IFModel.mRule>,\r\n cntRec? : ICntRec): Array<IFMatch.ICategorizedStringRanged> {\r\n  // simply apply all rules\r\n  debuglogV(()=> \"rules : \" + JSON.stringify(oRules, undefined, 2));\r\n  var res: Array<IMatch.ICategorizedStringRanged> = []\r\n  oRules.forEach(function (oRule) {\r\n    checkOneRuleWithOffset(word,lcword,exact,res,oRule,cntRec);\r\n  });\r\n  debuglog(`CSWWO: got results for ${lcword}  ${res.length}`);\r\n  res.sort(sortByRank);\r\n  return res;\r\n}\r\n\r\n/*\r\nexport function postFilter(res : Array<IFMatch.ICategorizedString>) : Array<IFMatch.ICategorizedString> {\r\n  res.sort(sortByRank);\r\n  var bestRank = 0;\r\n  //console.log(\"\\npiltered \" + JSON.stringify(res));\r\n    debuglog(()=> \"preFilter : \\n\" + res.map(function(word,index) {\r\n      return `${index} ${word._ranking}  => \"${word.category}\" ${word.matchedString}`;\r\n    }).join(\"\\n\"));\r\n  var r = res.filter(function(resx,index) {\r\n    if(index === 0) {\r\n      bestRank = resx._ranking;\r\n      return true;\r\n    }\r\n    // 1-0.9 = 0.1\r\n    // 1- 0.93 = 0.7\r\n    // 1/7\r\n    var delta = bestRank / resx._ranking;\r\n    if((resx.matchedString === res[index-1].matchedString)\r\n      && (resx.category === res[index-1].category)\r\n      ) {\r\n        debuglog('postfilter ignoring bitinidex!!!');\r\n      return false;\r\n    }\r\n    //console.log(\"\\n delta for \" + delta + \"  \" + resx._ranking);\r\n    if (resx.levenmatch && (delta > 1.03)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  });\r\n  debuglog(()=> `\\nfiltered ${r.length}/${res.length}` + JSON.stringify(r));\r\n  return r;\r\n}\r\n*/\r\n\r\n\r\nexport function dropLowerRankedEqualResult(res : Array<IFMatch.ICategorizedStringRanged>) : Array<IFMatch.ICategorizedStringRanged> {\r\n  res.sort(cmpByResultThenRank);\r\n  return res.filter(function(resx,index) {\r\n    var prior = res[index-1];\r\n    if( prior &&\r\n        !(resx.rule && resx.rule.range)\r\n     && !(res[index-1].rule && res[index-1].rule.range)\r\n     && (resx.matchedString === prior.matchedString)\r\n     && (resx.rule.bitindex === prior.rule.bitindex)\r\n     && (resx.rule.wordType === prior.rule.wordType)\r\n     && (resx.category === res[index-1].category)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  });\r\n}\r\n\r\n\r\nexport function postFilterWithOffset(res : Array<IFMatch.ICategorizedStringRanged>) : Array<IFMatch.ICategorizedStringRanged> {\r\n  // for filtering, we need to get *equal rule results close together\r\n  // =>\r\n  //\r\n\r\n  res.sort(sortByRank);\r\n  var bestRank = 0;\r\n  //console.log(\"\\npiltered \" + JSON.stringify(res));\r\n  debuglog(()=>\" preFilter : \\n\" + res.map(function(word) {\r\n      return ` ${word._ranking}  => \"${word.category}\" ${word.matchedString} `;\r\n    }).join(\"\\n\"));\r\n  var r = res.filter(function(resx,index) {\r\n    if(index === 0) {\r\n      bestRank = resx._ranking;\r\n      return true;\r\n    }\r\n    // 1-0.9 = 0.1\r\n    // 1- 0.93 = 0.7\r\n    // 1/7\r\n    var delta = bestRank / resx._ranking;\r\n    var prior = res[index-1];\r\n    if(\r\n        !(resx.rule && resx.rule.range)\r\n     && !(res[index-1].rule && res[index-1].rule.range)\r\n     && (resx.matchedString === prior.matchedString)\r\n     && (resx.rule.bitindex === prior.rule.bitindex)\r\n     && (resx.rule.wordType === prior.rule.wordType)\r\n     && (resx.category === res[index-1].category)) {\r\n      return false;\r\n    }\r\n    //console.log(\"\\n delta for \" + delta + \"  \" + resx._ranking);\r\n    if (resx.levenmatch && (delta > 1.03)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  });\r\n  r = dropLowerRankedEqualResult(res);\r\n  r.sort(sortByRankThenResult);\r\n  debuglog(()=>`\\nfiltered ${r.length}/${res.length}` + JSON.stringify(r));\r\n  return r;\r\n}\r\n\r\n/*\r\nexport function categorizeString2(word: string, exact: boolean,  rules : IFMatch.SplitRules\r\n  , cntRec? : ICntRec): Array<IFMatch.ICategorizedString> {\r\n  // simply apply all rules\r\n  if (debuglogM.enabled )  {\r\n    // TODO thisis ciruclar ! debuglogM(\"rules : \" + JSON.stringify(rules,undefined, 2));\r\n  }\r\n  var u = 1;\r\n  if( u === 1) {\r\n    throw new Error('categorized String2');\r\n\r\n  }\r\n  var lcString = word.toLowerCase();\r\n  var res: Array<IFMatch.ICategorizedString> = [];\r\n  if (exact) {\r\n    var r = rules.wordMap[lcString];\r\n    if (r) {\r\n      r.rules.forEach(function(oRule) {\r\n        res.push({\r\n            string: word,\r\n            matchedString: oRule.matchedString,\r\n            category: oRule.category,\r\n            _ranking: oRule._ranking || 1.0\r\n          })\r\n     });\r\n    }\r\n    rules.nonWordRules.forEach(function (oRule) {\r\n      checkOneRule(word,lcString,exact,res,oRule,cntRec);\r\n    });\r\n    res.sort(sortByRank);\r\n    return res;\r\n  } else {\r\n    debuglog(()=>\"categorize non exact\" + word + \" xx  \" + rules.allRules.length);\r\n    return postFilter(categorizeString(word, exact, rules.allRules, cntRec));\r\n  }\r\n}\r\n*/\r\n\r\n\r\nexport function categorizeWordInternalWithOffsets(word: string, lcword : string, exact: boolean,  rules : IMatch.SplitRules\r\n  , cntRec? :ICntRec): Array<IFMatch.ICategorizedStringRanged> {\r\n\r\n  debuglogM(\"categorize  CWIWO\" + lcword + \" with offset!!!!!!!!!!!!!!!!!\" + exact)\r\n  // simply apply all rules\r\n  if (debuglogV.enabled )  {\r\n    // TODO this is circular: debuglogV(\"rules : \" + JSON.stringify(rules,undefined, 2));\r\n  }\r\n  var res: Array<IMatch.ICategorizedStringRanged> = [];\r\n  if (exact) {\r\n    var r = rules.wordMap[lcword];\r\n    if (r) {\r\n      debuglogM(debuglogM.enabled ? ` ....pushing n rules exact for ${lcword}:` + r.rules.length : '-');\r\n      debuglogM(debuglogM.enabled ? r.rules.map((r,index)=> '' + index + ' ' + JSON.stringify(r)).join(\"\\n\") : '-');\r\n      r.rules.forEach(function(oRule) {\r\n        res.push({\r\n            string: word,\r\n            matchedString: oRule.matchedString,\r\n            category: oRule.category,\r\n            rule: oRule,\r\n            _ranking: oRule._ranking || 1.0\r\n          })\r\n     });\r\n    }\r\n    rules.nonWordRules.forEach(function (oRule) {\r\n      checkOneRuleWithOffset(word,lcword, exact,res,oRule,cntRec);\r\n    });\r\n    res = postFilterWithOffset(res);\r\n    debuglog(()=>\"here results exact for \" + word + \" res \" + res.length);\r\n    debuglogM(()=>\"here results exact for \" + word + \" res \" + res.length);\r\n    res.sort(sortByRank);\r\n    return res;\r\n  } else {\r\n    debuglog(\"categorize non exact \\\"\" + word + \"\\\"    \" + rules.allRules.length);\r\n    var rr = categorizeSingleWordWithOffset(word,lcword, exact, rules.allRules, cntRec);\r\n    //debulogM(\"fuzzy res \" + JSON.stringify(rr));\r\n    return postFilterWithOffset(rr);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n *\r\n * Options may be {\r\n * matchothers : true,  => only rules where all others match are considered\r\n * augment : true,\r\n * override : true }  =>\r\n *\r\n */\r\nexport function matchWord(oRule: IFModel.IRule, context: IFMatch.context, options?: IMatchOptions) {\r\n  if (context[oRule.key] === undefined) {\r\n    return undefined;\r\n  }\r\n  var s1 = context[oRule.key].toLowerCase()\r\n  var s2 = oRule.word.toLowerCase();\r\n  options = options || {}\r\n  var delta = compareContext(context, oRule.follows, oRule.key)\r\n  debuglogV(()=>JSON.stringify(delta));\r\n  debuglogV(()=>JSON.stringify(options));\r\n  if (options.matchothers && (delta.different > 0)) {\r\n    return undefined\r\n  }\r\n  var c: number = calcDistance(s2, s1);\r\n  debuglogV(() => \" s1 <> s2 \" + s1 + \"<>\" + s2 + \"  =>: \" + c);\r\n  if (c > 0.80) {\r\n    var res = AnyObject.assign({}, oRule.follows) as any;\r\n    res = AnyObject.assign(res, context);\r\n    if (options.override) {\r\n      res = AnyObject.assign(res, oRule.follows);\r\n    }\r\n    // force key property\r\n    // console.log(' objectcategory', res['systemObjectCategory']);\r\n    res[oRule.key] = oRule.follows[oRule.key] || res[oRule.key];\r\n    res._weight = AnyObject.assign({}, res._weight);\r\n    res._weight[oRule.key] = c;\r\n    Object.freeze(res);\r\n    debuglog(()=>'Found one' + JSON.stringify(res, undefined, 2));\r\n    return res;\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function extractArgsMap(match: Array<string>, argsMap: { [key: number]: string }): IFMatch.context {\r\n  var res = {} as IFMatch.context;\r\n  if (!argsMap) {\r\n    return res;\r\n  }\r\n  Object.keys(argsMap).forEach(function (iKey) {\r\n    var value = match[iKey]\r\n    var key = argsMap[iKey];\r\n    if ((typeof value === \"string\") && value.length > 0) {\r\n      res[key] = value\r\n    }\r\n  }\r\n  );\r\n  return res;\r\n}\r\n\r\nexport const RankWord = {\r\n  hasAbove: function (lst: Array<IFMatch.ICategorizedString>, border: number): boolean {\r\n    return !lst.every(function (oMember) {\r\n      return (oMember._ranking < border);\r\n    });\r\n  },\r\n\r\n  takeFirstN: function<T extends IFMatch.ICategorizedString> (lst: Array<T>, n: number): Array<T> {\r\n    var lastRanking = 1.0;\r\n    var cntRanged = 0;\r\n    return lst.filter(function (oMember, iIndex) {\r\n    var isRanged = !!(oMember[\"rule\"] && oMember[\"rule\"].range);\r\n    if(isRanged) {\r\n      cntRanged += 1;\r\n      return true;\r\n    }\r\n    if (((iIndex - cntRanged) < n) || (oMember._ranking === lastRanking))  {\r\n        lastRanking = oMember._ranking;\r\n        return true;\r\n      }\r\n      return false;\r\n    });\r\n  },\r\n  takeAbove : function<T extends IFMatch.ICategorizedString> (lst: Array<T>, border: number): Array<T> {\r\n    return lst.filter(function (oMember) {\r\n      return (oMember._ranking >= border);\r\n    });\r\n  }\r\n\r\n};\r\n\r\n/*\r\nvar exactLen = 0;\r\nvar fuzzyLen = 0;\r\nvar fuzzyCnt = 0;\r\nvar exactCnt = 0;\r\nvar totalCnt = 0;\r\nvar totalLen = 0;\r\nvar retainedCnt = 0;\r\n\r\nexport function resetCnt() {\r\n  exactLen = 0;\r\n  fuzzyLen = 0;\r\n  fuzzyCnt = 0;\r\n  exactCnt = 0;\r\n  totalCnt = 0;\r\n  totalLen = 0;\r\n  retainedCnt = 0;\r\n}\r\n*/\r\n\r\n/*\r\nexport function categorizeWordWithRankCutoff(sWordGroup: string, splitRules : IMatch.SplitRules , cntRec? : ICntRec ): Array<IFMatch.ICategorizedString> {\r\n  debuglog('cwwrc' + sWordGroup)\r\n  console.log('cwwrc called');\r\n  var u = 1;\r\n  var seenIt = categorizeString2(sWordGroup, true, splitRules, cntRec);\r\n  //totalCnt += 1;\r\n  // exactLen += seenIt.length;\r\n  addCntRec(cntRec, 'cntCatExact', 1);\r\n  addCntRec(cntRec, 'cntCatExactRes', seenIt.length);\r\n\r\n  if (RankWord.hasAbove(seenIt, 0.8)) {\r\n    if(cntRec) {\r\n      addCntRec(cntRec, 'exactPriorTake', seenIt.length)\r\n    }\r\n    seenIt = RankWord.takeAbove(seenIt, 0.8);\r\n    if(cntRec) {\r\n      addCntRec(cntRec, 'exactAfterTake', seenIt.length)\r\n    }\r\n   // exactCnt += 1;\r\n  } else {\r\n    seenIt = categorizeString2(sWordGroup, false, splitRules, cntRec);\r\n    addCntRec(cntRec, 'cntNonExact', 1);\r\n    addCntRec(cntRec, 'cntNonExactRes', seenIt.length);\r\n  //  fuzzyLen += seenIt.length;\r\n  //  fuzzyCnt += 1;\r\n  }\r\n // totalLen += seenIt.length;\r\n  seenIt = RankWord.takeFirstN(seenIt, Algol.Top_N_WordCategorizations);\r\n // retainedCnt += seenIt.length;\r\n  return seenIt;\r\n}\r\n*/\r\n\r\n/* if we have a  \"Run like the Wind\"\r\n  an a user type fun like  a Rind , and Rind is an exact match,\r\n  we will not start looking for the long sentence\r\n\r\n  this is to be fixed by \"spreading\" the range indication accross very similar words in the vincinity of the\r\n  target words\r\n*/\r\n\r\nexport function categorizeWordWithOffsetWithRankCutoff(sWordGroup: string, splitRules : IMatch.SplitRules, cntRec? : ICntRec ): Array<IFMatch.ICategorizedStringRanged> {\r\n  var sWordGroupLC = sWordGroup.toLowerCase();\r\n  var seenIt = categorizeWordInternalWithOffsets(sWordGroup, sWordGroupLC, true, splitRules, cntRec);\r\n  //console.log(\"SEENIT\" + JSON.stringify(seenIt));\r\n  //totalCnt += 1;\r\n  // exactLen += seenIt.length;\r\n  //console.log(\"first run exact \" + JSON.stringify(seenIt));\r\n  addCntRec(cntRec, 'cntCatExact', 1);\r\n  addCntRec(cntRec, 'cntCatExactRes', seenIt.length);\r\n\r\n  if (RankWord.hasAbove(seenIt, 0.8)) {\r\n    if(cntRec) {\r\n      addCntRec(cntRec, 'exactPriorTake', seenIt.length)\r\n    }\r\n    seenIt = RankWord.takeAbove(seenIt, 0.8);\r\n    if(cntRec) {\r\n      addCntRec(cntRec, 'exactAfterTake', seenIt.length)\r\n    }\r\n   // exactCnt += 1;\r\n  } else {\r\n    seenIt = categorizeWordInternalWithOffsets(sWordGroup, sWordGroupLC, false, splitRules, cntRec);\r\n    addCntRec(cntRec, 'cntNonExact', 1);\r\n    addCntRec(cntRec, 'cntNonExactRes', seenIt.length);\r\n  //  fuzzyLen += seenIt.length;\r\n  //  fuzzyCnt += 1;\r\n  }\r\n  // totalLen += seenIt.length;\r\n  debuglog(()=>( `${seenIt.length} with ${seenIt.reduce( (prev,obj) => prev + (obj.rule.range ? 1 : 0),0)} ranged !`));\r\n//  var cntRanged = seenIt.reduce( (prev,obj) => prev + (obj.rule.range ? 1 : 0),0);\r\n//  console.log(`*********** ${seenIt.length} with ${cntRanged} ranged !`);\r\n\r\n  seenIt = RankWord.takeFirstN(seenIt, Algol.Top_N_WordCategorizations);\r\n // retainedCnt += seenIt.length;\r\n  //console.log(\"final res of categorizeWordWithOffsetWithRankCutoff\" + JSON.stringify(seenIt));\r\n\r\n  return seenIt;\r\n}\r\n\r\n\r\nexport function categorizeWordWithOffsetWithRankCutoffSingle(word: string, rule: IFModel.mRule): IFMatch.ICategorizedStringRanged {\r\n  var lcword = word.toLowerCase();\r\n\r\n  if(lcword === rule.lowercaseword) {\r\n    return {\r\n            string: word,\r\n            matchedString: rule.matchedString,\r\n            category: rule.category,\r\n            rule: rule,\r\n            _ranking: rule._ranking || 1.0\r\n          };\r\n  }\r\n\r\n  var res: Array<IMatch.ICategorizedStringRanged> = []\r\n  checkOneRuleWithOffset(word,lcword,false,res,rule);\r\n  debuglog(\"catWWOWRCS \" + lcword);\r\n  if(res.length) {\r\n    return res[0];\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\n\r\n/*\r\nexport function filterRemovingUncategorizedSentence(oSentence: IFMatch.ICategorizedString[][]): boolean {\r\n  return oSentence.every(function (oWordGroup) {\r\n    return (oWordGroup.length > 0);\r\n  });\r\n}\r\n\r\n\r\n\r\nexport function filterRemovingUncategorized(arr: IFMatch.ICategorizedString[][][]): IFMatch.ICategorizedString[][][] {\r\n  return arr.filter(function (oSentence) {\r\n    return filterRemovingUncategorizedSentence(oSentence);\r\n  });\r\n}\r\n*/\r\n\r\nexport function categorizeAWord(sWordGroup: string, rules: IMatch.SplitRules, sentence: string, words: { [key: string]: Array<IFMatch.ICategorizedString>},\r\ncntRec ? : ICntRec ) : IMatch.ICategorizedStringRanged[] {\r\n  return categorizeAWordWithOffsets(sWordGroup, rules, sentence, words).filter(\r\n     r => !r.span && !r.rule.range\r\n  );\r\n/* consider removing the ranged stuff  */\r\n\r\n\r\n/*\r\n  var seenIt = words[sWordGroup];\r\n  if (seenIt === undefined) {\r\n    //seenIt = categorizeWordWithRankCutoff(sWordGroup, rules, cntRec);\r\n    seenIt = categorizeWordWithOffsetWithRankCutoff(sWordGroup,rules,cntRec);\r\n    utils.deepFreeze(seenIt);\r\n    words[sWordGroup] = seenIt;\r\n  }\r\n  if (!seenIt || seenIt.length === 0) {\r\n    logger(\"***WARNING: Did not find any categorization for \\\"\" + sWordGroup + \"\\\" in sentence \\\"\"\r\n      + sentence + \"\\\"\");\r\n    if (sWordGroup.indexOf(\" \") <= 0) {\r\n      debuglog(\"***WARNING: Did not find any categorization for primitive (!)\" + sWordGroup);\r\n    }\r\n    debuglog(\"***WARNING: Did not find any categorization for \" + sWordGroup);\r\n    if (!seenIt) {\r\n      throw new Error(\"Expecting emtpy list, not undefined for \\\"\" + sWordGroup + \"\\\"\")\r\n    }\r\n    words[sWordGroup] = []\r\n    return [];\r\n  }\r\n  return utils.cloneDeep(seenIt);\r\n  */\r\n}\r\n\r\n\r\n/**\r\n * Given a  string, break it down into components,\r\n * [['A', 'B'], ['A B']]\r\n *\r\n * then categorizeWords\r\n * returning\r\n *\r\n * [ [[ { category: 'systemId', word : 'A'},\r\n *      { category: 'otherthing', word : 'A'}\r\n *    ],\r\n *    // result of B\r\n *    [ { category: 'systemId', word : 'B'},\r\n *      { category: 'otherthing', word : 'A'}\r\n *      { category: 'anothertryp', word : 'B'}\r\n *    ]\r\n *   ],\r\n * ]]]\r\n *\r\n *\r\n *\r\n */\r\n\r\n/*\r\nexport function analyzeString(sString: string, rules: IMatch.SplitRules,\r\n  words?: { [key: string]: Array<IFMatch.ICategorizedString> })\r\n  : [ [ IMatch.ICategorizedString[]] ]\r\n   {\r\n  var cnt = 0;\r\n  var fac = 1;\r\n  if(cnt === 0) {\r\n    throw Error('use processStrign2');\r\n  }\r\n  var u = breakdown.breakdownString(sString, Algol.MaxSpacesPerCombinedWord);\r\n  debuglog(()=>\"here breakdown\" + JSON.stringify(u));\r\n  //console.log(JSON.stringify(u));\r\n  words = words || {};\r\n  debugperf(()=>'this many known words: ' + Object.keys(words).length);\r\n  var res = [] as [[ IMatch.ICategorizedString[]] ];\r\n  var cntRec = {};\r\n  u.forEach(function (aBreakDownSentence) {\r\n      var categorizedSentence = [] as [ IMatch.ICategorizedString[] ];\r\n      var isValid = aBreakDownSentence.every(function (sWordGroup: string, index : number) {\r\n        var seenIt = categorizeAWord(sWordGroup, rules, sString, words, cntRec);\r\n        if(seenIt.length === 0) {\r\n          return false;\r\n        }\r\n        categorizedSentence[index] = seenIt;\r\n        cnt = cnt + seenIt.length;\r\n        fac = fac * seenIt.length;\r\n        return true;\r\n      });\r\n      if(isValid) {\r\n        res.push(categorizedSentence);\r\n      }\r\n  });\r\n  debuglog(()=>\" sentences \" + u.length + \" matches \" + cnt + \" fac: \" + fac);\r\n  debuglog( ()=> \"first match \"+ JSON.stringify(u,undefined,2));\r\n  debugperf(()=> \" sentences \" + u.length + \" / \" + res.length +  \" matches \" + cnt + \" fac: \" + fac + \" rec : \" + JSON.stringify(cntRec,undefined,2));\r\n  return res;\r\n}\r\n*/\r\n\r\n\r\n/**\r\n * This is the main entry point for word categorization,\r\n * If sentence is supplied it will be used\r\n * @param sWordGroup a single word, g.e. \"earth\" or a combination \"UI5 Component\"\r\n *  The word will *not* be broken down here, but diretyl matched against  rules\r\n * @param rules rule index\r\n * @param sentence optional, only for debugging\r\n * @param words\r\n * @param cntRec\r\n */\r\nexport function categorizeAWordWithOffsets(sWordGroup: string, rules: IMatch.SplitRules, sentence: string, words: { [key: string]: Array<IFMatch.ICategorizedString>},\r\ncntRec ? : ICntRec ) : IMatch.ICategorizedStringRanged[] {\r\n  var seenIt = words[sWordGroup];\r\n  if (seenIt === undefined) {\r\n    seenIt = categorizeWordWithOffsetWithRankCutoff(sWordGroup, rules, cntRec);\r\n    utils.deepFreeze(seenIt);\r\n    words[sWordGroup] = seenIt;\r\n  }\r\n  if (!seenIt || seenIt.length === 0) {\r\n    logger(\"***WARNING: Did not find any categorization for \\\"\" + sWordGroup + \"\\\" in sentence \\\"\"\r\n      + sentence + \"\\\"\");\r\n    if (sWordGroup.indexOf(\" \") <= 0) {\r\n      debuglog(()=>\"***WARNING: Did not find any categorization for primitive (!)\" + sWordGroup);\r\n    }\r\n    debuglog(()=>\"***WARNING: Did not find any categorization for \" + sWordGroup);\r\n    if (!seenIt) {\r\n      throw new Error(\"Expecting emtpy list, not undefined for \\\"\" + sWordGroup + \"\\\"\")\r\n    }\r\n    words[sWordGroup] = []\r\n    return [];\r\n  }\r\n  return utils.cloneDeep(seenIt);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n[ [a,b], [c,d]]\r\n\r\n00 a\r\n01 b\r\n10 c\r\n11 d\r\n12 c\r\n*/\r\n\r\n\r\nconst clone = utils.cloneDeep;\r\n\r\n\r\nfunction copyVecMembers(u) {\r\n  var i = 0;\r\n  for(i = 0; i < u.length; ++i) {\r\n    u[i] = clone(u[i]);\r\n  }\r\n  return u;\r\n}\r\n// we can replicate the tail or the head,\r\n// we replicate the tail as it is smaller.\r\n\r\n// [a,b,c ]\r\n\r\nexport function expandMatchArr(deep: Array<Array<any>>): Array<Array<any>> {\r\n  var a = [];\r\n  var line = [];\r\n  debuglog(()=> JSON.stringify(deep));\r\n  deep.forEach(function (uBreakDownLine, iIndex: number) {\r\n    line[iIndex] = [];\r\n    uBreakDownLine.forEach(function (aWordGroup, wgIndex: number) {\r\n      line[iIndex][wgIndex] = [];\r\n      aWordGroup.forEach(function (oWordVariant, iWVIndex: number) {\r\n        line[iIndex][wgIndex][iWVIndex] = oWordVariant;\r\n      });\r\n    });\r\n  })\r\n  debuglog(debuglog.enabled ? JSON.stringify(line) : '-');\r\n  var res = [];\r\n  var nvecs = [];\r\n  for (var i = 0; i < line.length; ++i) {\r\n    var vecs = [[]];\r\n    var nvecs = [];\r\n    var rvec = [];\r\n    for (var k = 0; k < line[i].length; ++k) { // wordgroup k\r\n      //vecs is the vector of all so far seen variants up to k wgs.\r\n      var nextBase = [];\r\n      for (var l = 0; l < line[i][k].length; ++l) { // for each variant\r\n        //debuglog(\"vecs now\" + JSON.stringify(vecs));\r\n        nvecs = []; //vecs.slice(); // copy the vec[i] base vector;\r\n        //debuglog(\"vecs copied now\" + JSON.stringify(nvecs));\r\n        for (var u = 0; u < vecs.length; ++u) {\r\n          nvecs[u] = vecs[u].slice(); //\r\n          nvecs[u] = copyVecMembers(nvecs[u]);\r\n          // debuglog(\"copied vecs[\"+ u+\"]\" + JSON.stringify(vecs[u]));\r\n          nvecs[u].push(\r\n            clone(line[i][k][l])); // push the lth variant\r\n          // debuglog(\"now nvecs \" + nvecs.length + \" \" + JSON.stringify(nvecs));\r\n        }\r\n        //   debuglog(\" at     \" + k + \":\" + l + \" nextbase >\" + JSON.stringify(nextBase))\r\n        //   debuglog(\" append \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nvecs))\r\n        nextBase = nextBase.concat(nvecs);\r\n        //   debuglog(\"  result \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nextBase))\r\n      } //constru\r\n      //  debuglog(\"now at \" + k + \":\" + l + \" >\" + JSON.stringify(nextBase))\r\n      vecs = nextBase;\r\n    }\r\n    debuglogV(debuglogV.enabled ? (\"APPENDING TO RES\" + i + \":\" + l + \" >\" + JSON.stringify(nextBase)) : '-');\r\n    res = res.concat(vecs);\r\n  }\r\n  return res;\r\n}\r\n\r\n\r\n/**\r\n * Calculate a weight factor for a given distance and\r\n * category\r\n * @param {integer} dist distance in words\r\n * @param {string} category category to use\r\n * @returns {number} a distance factor >= 1\r\n *  1.0 for no effect\r\n */\r\nexport function reinforceDistWeight(dist: number, category: string): number {\r\n  var abs = Math.abs(dist);\r\n  return 1.0 + (Algol.aReinforceDistWeight[abs] || 0);\r\n}\r\n\r\n/**\r\n * Given a sentence, extact categories\r\n */\r\nexport function extractCategoryMap(oSentence: Array<IFMatch.IWord>): { [key: string]: Array<{ pos: number }> } {\r\n  var res = {};\r\n  debuglog(debuglog.enabled ? ('extractCategoryMap ' + JSON.stringify(oSentence)) : '-');\r\n  oSentence.forEach(function (oWord, iIndex) {\r\n    if (oWord.category === IFMatch.CAT_CATEGORY) {\r\n      res[oWord.matchedString] = res[oWord.matchedString] || [];\r\n      res[oWord.matchedString].push({ pos: iIndex });\r\n    }\r\n  });\r\n  utils.deepFreeze(res);\r\n  return res;\r\n}\r\n\r\nexport function reinForceSentence(oSentence) {\r\n  \"use strict\";\r\n  var oCategoryMap = extractCategoryMap(oSentence);\r\n  oSentence.forEach(function (oWord, iIndex) {\r\n    var m = oCategoryMap[oWord.category] || [];\r\n    m.forEach(function (oPosition: { pos: number }) {\r\n      \"use strict\";\r\n      oWord.reinforce = oWord.reinforce || 1;\r\n      var boost = reinforceDistWeight(iIndex - oPosition.pos, oWord.category);\r\n      oWord.reinforce *= boost;\r\n      oWord._ranking *= boost;\r\n    });\r\n  });\r\n  oSentence.forEach(function (oWord, iIndex) {\r\n    if (iIndex > 0 ) {\r\n      if (oSentence[iIndex-1].category === \"meta\"  && (oWord.category === oSentence[iIndex-1].matchedString) ) {\r\n        oWord.reinforce = oWord.reinforce || 1;\r\n        var boost = reinforceDistWeight(1, oWord.category);\r\n        oWord.reinforce *= boost;\r\n        oWord._ranking *= boost;\r\n      }\r\n    }\r\n  });\r\n  return oSentence;\r\n}\r\n\r\n\r\nimport * as Sentence from './sentence';\r\n\r\nexport function reinForce(aCategorizedArray) {\r\n  \"use strict\";\r\n  aCategorizedArray.forEach(function (oSentence) {\r\n    reinForceSentence(oSentence);\r\n  })\r\n  aCategorizedArray.sort(Sentence.cmpRankingProduct);\r\n debuglog(()=>\"after reinforce\" + aCategorizedArray.map(function (oSentence) {\r\n      return Sentence.rankingProduct(oSentence) + \":\" + JSON.stringify(oSentence);\r\n    }).join(\"\\n\"));\r\n  return aCategorizedArray;\r\n}\r\n\r\n\r\n/// below may no longer be used\r\n\r\nexport function matchRegExp(oRule: IFModel.IRule, context: IFMatch.context, options?: IMatchOptions) {\r\n  if (context[oRule.key] === undefined) {\r\n    return undefined;\r\n  }\r\n  var sKey = oRule.key;\r\n  var s1 = context[oRule.key].toLowerCase()\r\n  var reg = oRule.regexp;\r\n\r\n  var m = reg.exec(s1);\r\n  if(debuglogV.enabled) {\r\n    debuglogV(\"applying regexp: \" + s1 + \" \" + JSON.stringify(m));\r\n  }\r\n  if (!m) {\r\n    return undefined;\r\n  }\r\n  options = options || {}\r\n  var delta = compareContext(context, oRule.follows, oRule.key)\r\n  debuglogV(()=>JSON.stringify(delta));\r\n  debuglogV(()=>JSON.stringify(options));\r\n  if (options.matchothers && (delta.different > 0)) {\r\n    return undefined\r\n  }\r\n  var oExtractedContext = extractArgsMap(m, oRule.argsMap);\r\n  debuglogV(()=>\"extracted args \" + JSON.stringify(oRule.argsMap));\r\n  debuglogV(()=>\"match \" + JSON.stringify(m));\r\n  debuglogV(()=>\"extracted args \" + JSON.stringify(oExtractedContext));\r\n  var res = AnyObject.assign({}, oRule.follows) as any;\r\n  res = AnyObject.assign(res, oExtractedContext);\r\n  res = AnyObject.assign(res, context);\r\n  if (oExtractedContext[sKey] !== undefined) {\r\n    res[sKey] = oExtractedContext[sKey];\r\n  }\r\n  if (options.override) {\r\n    res = AnyObject.assign(res, oRule.follows);\r\n    res = AnyObject.assign(res, oExtractedContext)\r\n  }\r\n  Object.freeze(res);\r\n  debuglog(debuglog.enabled ? ('Found one' + JSON.stringify(res, undefined, 2)) : '-');\r\n  return res;\r\n}\r\n\r\nexport function sortByWeight(sKey: string, oContextA: IFMatch.context, oContextB: IFMatch.context): number {\r\n  debuglogV(()=>'sorting: ' + sKey + 'invoked with\\n 1:' + JSON.stringify(oContextA, undefined, 2) +\r\n    \" vs \\n 2:\" + JSON.stringify(oContextB, undefined, 2));\r\n  var rankingA: number = parseFloat(oContextA[\"_ranking\"] || \"1\");\r\n  var rankingB: number = parseFloat(oContextB[\"_ranking\"] || \"1\");\r\n  if (rankingA !== rankingB) {\r\n    debuglog(()=> \" rankin delta\" + 100 * (rankingB - rankingA));\r\n    return 100 * (rankingB - rankingA)\r\n  }\r\n\r\n  var weightA = oContextA[\"_weight\"] && oContextA[\"_weight\"][sKey] || 0;\r\n  var weightB = oContextB[\"_weight\"] && oContextB[\"_weight\"][sKey] || 0;\r\n  return +(weightB - weightA);\r\n}\r\n\r\n\r\n// Word, Synonym, Regexp / ExtractionRule\r\n\r\nexport function augmentContext1(context: IFMatch.context, oRules: Array<IFModel.IRule>, options: IMatchOptions): Array<IFMatch.context> {\r\n  var sKey = oRules[0].key;\r\n  // check that rule\r\n  if (debuglog.enabled) {\r\n    // check consistency\r\n    oRules.every(function (iRule) {\r\n      if (iRule.key !== sKey) {\r\n        throw new Error(\"Inhomogenous keys in rules, expected \" + sKey + \" was \" + JSON.stringify(iRule));\r\n      }\r\n      return true;\r\n    });\r\n  }\r\n\r\n  // look for rules which match\r\n  var res = oRules.map(function (oRule) {\r\n    // is this rule applicable\r\n    switch (oRule.type) {\r\n      case IFModel.EnumRuleType.WORD:\r\n        return matchWord(oRule, context, options)\r\n      case IFModel.EnumRuleType.REGEXP:\r\n        return matchRegExp(oRule, context, options);\r\n      //   case \"Extraction\":\r\n      //     return matchExtraction(oRule,context);\r\n    }\r\n    return undefined\r\n  }).filter(function (ores) {\r\n    return !!ores\r\n  }).sort(\r\n    sortByWeight.bind(this, sKey)\r\n    );\r\n    //debuglog(\"hassorted\" + JSON.stringify(res,undefined,2));\r\n  return res;\r\n  // Object.keys().forEach(function (sKey) {\r\n  // });\r\n}\r\n\r\nexport function augmentContext(context: IFMatch.context, aRules: Array<IFModel.IRule>): Array<IFMatch.context> {\r\n\r\n  var options1: IMatchOptions = {\r\n    matchothers: true,\r\n    override: false\r\n  } as IMatchOptions;\r\n\r\n  var aRes = augmentContext1(context, aRules, options1)\r\n\r\n  if (aRes.length === 0) {\r\n    var options2: IMatchOptions = {\r\n      matchothers: false,\r\n      override: true\r\n    } as IMatchOptions;\r\n    aRes = augmentContext1(context, aRules, options2);\r\n  }\r\n  return aRes;\r\n}\r\n"],"sourceRoot":"/source/"}