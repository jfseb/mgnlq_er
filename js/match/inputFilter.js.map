{"version":3,"sources":["/projects/nodejs/botbuilder/abot_stringdist/src/../src/match/inputFilter.ts"],"names":[],"mappings":"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","file":"match/inputFilter.js","sourcesContent":["/**\r\n * the input filter stage preprocesses a current context\r\n *\r\n * It a) combines multi-segment arguments into one context members\r\n * It b) attempts to augment the context by additional qualifications\r\n *           (Mid term generating Alternatives, e.g.\r\n *                 ClientSideTargetResolution -> unit test?\r\n *                 ClientSideTargetResolution -> source ?\r\n *           )\r\n *  Simple rules like  Intent\r\n *\r\n *\r\n * @module jfseb.fdevstart.inputFilter\r\n * @file inputFilter.ts\r\n * @copyright (c) 2016 Gerd Forstmann\r\n */\r\n// <reference path=\"../../lib/node-4.d.ts\" />\r\nimport * as distance from 'abot_stringdist';\r\n\r\n//import * as Logger from '../utils/logger';\r\n\r\n//const logger = Logger.logger('inputFilter');\r\n\r\nimport * as debug from 'debugf';\r\nvar debugperf = debug('perf');\r\nvar logger = debug('inputFilterLogger');\r\n\r\nimport {IFModel as IFModel} from 'mgnlq_model';\r\nimport * as utils from 'abot_utils';\r\n\r\n//import * as IFMatch from '../match/iferbase';\r\n\r\n\r\n//import * as inputFilterRules from './inputFilterRules';\r\n\r\nimport * as Algol from './algol';\r\n\r\nimport * as IFMatch from './iferbase';\r\nimport * as IMatch from './iferbase';\r\n\r\nimport { BreakDown as breakdown} from 'mgnlq_model';\r\n\r\nconst AnyObject = <any>Object;\r\n\r\nvar debuglog = debug('inputFilter')\r\nvar debuglogV = debug('inputVFilter')\r\nvar debuglogM = debug('inputMFilter')\r\n\r\nexport function mockDebug(o) {\r\n  debuglog = o;\r\n  debuglogV = o;\r\n  debuglogM = o;\r\n}\r\n\r\n\r\n/**\r\n * @param sText {string} the text to match to NavTargetResolution\r\n * @param sText2 {string} the query text, e.g. NavTarget\r\n *\r\n * @return the distance, note that is is *not* symmetric!\r\n */\r\nexport function calcDistance(sText1: string, sText2: string): number {\r\n  return distance.calcDistanceAdjusted(sText1,sText2);\r\n}\r\n\r\n\r\nexport interface ICntRec {\r\n\r\n};\r\n\r\n\r\n/**\r\n * @param sText {string} the text to match to NavTargetResolution\r\n * @param sText2 {string} the query text, e.g. NavTarget\r\n *\r\n * @return the distance, note that is is *not* symmetric!\r\n */\r\n/*\r\nexport function calcDistanceLevenXXX(sText1: string, sText2: string): number {\r\n  // console.log(\"length2\" + sText1 + \" - \" + sText2)\r\n   if(((sText1.length - sText2.length) > Algol.calcDist.lengthDelta1)\r\n    || (sText2.length > 1.5 * sText1.length )\r\n    || (sText2.length < (sText1.length/2)) ) {\r\n    return 50000;\r\n  }\r\n  var a0 = distance.levenshtein(sText1.substring(0, sText2.length), sText2)\r\n  if(debuglogV.enabled) {\r\n    debuglogV(\"distance\" + a0 + \"stripped>\" + sText1.substring(0,sText2.length) + \"<>\" + sText2+ \"<\");\r\n  }\r\n  if(a0 * 50 > 15 * sText2.length) {\r\n      return 40000;\r\n  }\r\n  var a = distance.levenshtein(sText1, sText2)\r\n  return a0 * 500 / sText2.length + a\r\n}\r\n*/\r\n\r\n\r\n\r\n\r\ntype IRule = IFMatch.IRule\r\n\r\n\r\nexport interface IMatchOptions {\r\n  matchothers?: boolean,\r\n  augment?: boolean,\r\n  override?: boolean\r\n}\r\n\r\ninterface IMatchCount {\r\n  equal: number\r\n  different: number\r\n  spuriousR: number\r\n  spuriousL: number\r\n}\r\n\r\ntype EnumRuleType = IFModel.EnumRuleType\r\n\r\n//const levenCutoff = Algol.Cutoff_LevenShtein;\r\n\r\n/*\r\nexport function levenPenaltyOld(i: number): number {\r\n  // 0-> 1\r\n  // 1 -> 0.1\r\n  // 150 ->  0.8\r\n  if (i === 0) {\r\n    return 1;\r\n  }\r\n  // reverse may be better than linear\r\n  return 1 + i * (0.8 - 1) / 150\r\n}\r\n*/\r\n\r\nexport function levenPenalty(i: number): number {\r\n  // 1 -> 1\r\n  // cutOff => 0.8\r\n  return i;\r\n  //return   1 -  (1 - i) *0.2/Algol.Cutoff_WordMatch;\r\n}\r\n\r\n\r\nfunction nonPrivateKeys(oA) {\r\n  return Object.keys(oA).filter(key => {\r\n    return key[0] !== '_';\r\n  });\r\n}\r\n\r\nexport function countAinB(oA, oB, fnCompare, aKeyIgnore?): number {\r\n  aKeyIgnore = Array.isArray(aKeyIgnore) ? aKeyIgnore :\r\n    typeof aKeyIgnore === \"string\" ? [aKeyIgnore] : [];\r\n  fnCompare = fnCompare || function () { return true; }\r\n  return nonPrivateKeys(oA).filter(function (key) {\r\n    return aKeyIgnore.indexOf(key) < 0;\r\n  }).\r\n    reduce(function (prev, key) {\r\n      if (Object.prototype.hasOwnProperty.call(oB, key)) {\r\n        prev = prev + (fnCompare(oA[key], oB[key], key) ? 1 : 0)\r\n      }\r\n      return prev\r\n    }, 0)\r\n}\r\n\r\nexport function spuriousAnotInB(oA, oB, aKeyIgnore?) {\r\n  aKeyIgnore = Array.isArray(aKeyIgnore) ? aKeyIgnore :\r\n    typeof aKeyIgnore === \"string\" ? [aKeyIgnore] : [];\r\n  return nonPrivateKeys(oA).filter(function (key) {\r\n    return aKeyIgnore.indexOf(key) < 0;\r\n  }).\r\n    reduce(function (prev, key) {\r\n      if (!Object.prototype.hasOwnProperty.call(oB, key)) {\r\n        prev = prev + 1\r\n      }\r\n      return prev\r\n    }, 0)\r\n}\r\n\r\nfunction lowerCase(o) {\r\n  if (typeof o === \"string\") {\r\n    return o.toLowerCase()\r\n  }\r\n  return o\r\n}\r\n\r\nexport function compareContext(oA, oB, aKeyIgnore?) {\r\n  var equal = countAinB(oA, oB, function (a, b) { return lowerCase(a) === lowerCase(b); }, aKeyIgnore);\r\n  var different = countAinB(oA, oB, function (a, b) { return lowerCase(a) !== lowerCase(b); }, aKeyIgnore);\r\n  var spuriousL = spuriousAnotInB(oA, oB, aKeyIgnore)\r\n  var spuriousR = spuriousAnotInB(oB, oA, aKeyIgnore)\r\n  return {\r\n    equal: equal,\r\n    different: different,\r\n    spuriousL: spuriousL,\r\n    spuriousR: spuriousR\r\n  }\r\n}\r\n\r\nfunction sortByRank(a: IFMatch.ICategorizedString, b: IFMatch.ICategorizedString): number {\r\n  var r = -((a._ranking || 1.0) - (b._ranking || 1.0));\r\n  if (r) {\r\n    return r;\r\n  }\r\n  if (a.category && b.category) {\r\n    r = a.category.localeCompare(b.category);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  if (a.matchedString && b.matchedString) {\r\n    r = a.matchedString.localeCompare(b.matchedString);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction cmpByRank(a: IFMatch.ICategorizedString, b: IFMatch.ICategorizedString): number {\r\n  return sortByRank(a,b);\r\n}\r\n\r\n\r\nfunction sortByRankThenResult(a: IFMatch.ICategorizedStringRanged, b: IFMatch.ICategorizedStringRanged): number {\r\n  var r = -((a._ranking || 1.0) - (b._ranking || 1.0));\r\n  if (r) {\r\n    return r;\r\n  }\r\n  if (a.category && b.category) {\r\n    r = a.category.localeCompare(b.category);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  if (a.matchedString && b.matchedString) {\r\n    r = a.matchedString.localeCompare(b.matchedString);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  r = cmpByResultThenRank(a,b);\r\n  if(r) {\r\n    return r;\r\n  }\r\n  return 0;\r\n}\r\n\r\n\r\nexport function cmpByResult(a: IFMatch.ICategorizedStringRanged, b: IFMatch.ICategorizedStringRanged): number {\r\n  if(a.rule === b.rule) {\r\n    return 0;\r\n  }\r\n  var r = a.rule.bitindex - b.rule.bitindex;\r\n  if(r) {\r\n    return r;\r\n  }\r\n  if (a.rule.matchedString && b.rule.matchedString) {\r\n    r = a.rule.matchedString.localeCompare(b.rule.matchedString);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  if (a.rule.category && b.rule.category) {\r\n    r = a.rule.category.localeCompare(b.rule.category);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  if (a.rule.wordType && b.rule.wordType) {\r\n    r = a.rule.wordType.localeCompare(b.rule.wordType);\r\n    if (r) {\r\n      return r;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n\r\n\r\nexport function cmpByResultThenRank(a: IFMatch.ICategorizedStringRanged, b: IFMatch.ICategorizedStringRanged): number {\r\n  var r = cmpByResult(a,b);\r\n  if (r) {\r\n    return r;\r\n  }\r\n  var r = -((a._ranking || 1.0) - (b._ranking || 1.0));\r\n  if (r) {\r\n    return r;\r\n  }\r\n  // TODO consider a tiebreaker here\r\n  return 0;\r\n}\r\n\r\n\r\n\r\n\r\nexport function checkOneRule(string: string, lcString : string, exact : boolean,\r\nres : Array<IFMatch.ICategorizedString>,\r\noRule : IFModel.mRule, cntRec? : ICntRec ) {\r\n   if (debuglogV.enabled) {\r\n      debuglogV('attempting to match rule ' + JSON.stringify(oRule) + \" to string \\\"\" + string + \"\\\"\");\r\n    }\r\n    switch (oRule.type) {\r\n      case IFModel.EnumRuleType.WORD:\r\n        if(!oRule.lowercaseword) {\r\n          throw new Error('rule without a lowercase variant' + JSON.stringify(oRule, undefined, 2));\r\n         };\r\n        if (exact && oRule.word === string || oRule.lowercaseword === lcString) {\r\n          if(debuglog.enabled) {\r\n            debuglog(\"\\n!matched exact \" + string + \"=\"  + oRule.lowercaseword  + \" => \" + oRule.matchedString + \"/\" + oRule.category);\r\n          }\r\n          res.push({\r\n            string: string,\r\n            matchedString: oRule.matchedString,\r\n            category: oRule.category,\r\n            _ranking: oRule._ranking || 1.0\r\n          })\r\n        }\r\n        if (!exact && !oRule.exactOnly) {\r\n          var levenmatch = calcDistance(oRule.lowercaseword, lcString);\r\n\r\n/*\r\n          addCntRec(cntRec,\"calcDistance\", 1);\r\n          if(levenmatch < 50) {\r\n            addCntRec(cntRec,\"calcDistanceExp\", 1);\r\n          }\r\n          if(levenmatch < 40000) {\r\n            addCntRec(cntRec,\"calcDistanceBelow40k\", 1);\r\n          }\r\n          */\r\n          //if(oRule.lowercaseword === \"cosmos\") {\r\n          //  console.log(\"here ranking \" + levenmatch + \" \" + oRule.lowercaseword + \" \" + lcString);\r\n          //}\r\n          if (levenmatch >= Algol.Cutoff_WordMatch) { // levenCutoff) {\r\n            addCntRec(cntRec,\"calcDistanceOk\", 1);\r\n            var rec = {\r\n              string: string,\r\n              matchedString: oRule.matchedString,\r\n              category: oRule.category,\r\n              _ranking: (oRule._ranking || 1.0) * levenPenalty(levenmatch),\r\n              levenmatch: levenmatch\r\n            };\r\n            if(debuglog) {\r\n              debuglog(\"\\n!fuzzy \" + (levenmatch).toFixed(3) + \" \" + rec._ranking.toFixed(3) + \"  \" + string + \"=\"  + oRule.lowercaseword  + \" => \" + oRule.matchedString + \"/\" + oRule.category);\r\n            }\r\n            res.push(rec);\r\n          }\r\n        }\r\n        break;\r\n      case IFModel.EnumRuleType.REGEXP: {\r\n        if (debuglog.enabled) {\r\n          debuglog(JSON.stringify(\" here regexp\" + JSON.stringify(oRule, undefined, 2)))\r\n        }\r\n        var m = oRule.regexp.exec(string)\r\n        if (m) {\r\n          res.push({\r\n            string: string,\r\n            matchedString: (oRule.matchIndex !== undefined && m[oRule.matchIndex]) || string,\r\n            category: oRule.category,\r\n            _ranking: oRule._ranking || 1.0\r\n          })\r\n        }\r\n      }\r\n        break;\r\n      default:\r\n        throw new Error(\"unknown type\" + JSON.stringify(oRule, undefined, 2))\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function checkOneRuleWithOffset(string: string, lcString : string, exact : boolean,\r\nres : Array<IMatch.ICategorizedStringRanged>,\r\noRule : IFModel.mRule, cntRec? : ICntRec ) {\r\n   if (debuglogV.enabled) {\r\n      debuglogV('attempting to match rule ' + JSON.stringify(oRule) + \" to string \\\"\" + string + \"\\\"\");\r\n    }\r\n    switch (oRule.type) {\r\n      case IFModel.EnumRuleType.WORD:\r\n        if(!oRule.lowercaseword) {\r\n          throw new Error('rule without a lowercase variant' + JSON.stringify(oRule, undefined, 2));\r\n         };\r\n        if (exact && (oRule.word === string || oRule.lowercaseword === lcString)) {\r\n          if(debuglog.enabled) {\r\n            debuglog(\"\\n!matched exact \" + string + \"=\"  + oRule.lowercaseword  + \" => \" + oRule.matchedString + \"/\" + oRule.category);\r\n          }\r\n          res.push({\r\n            string: string,\r\n            matchedString: oRule.matchedString,\r\n            category: oRule.category,\r\n            rule: oRule,\r\n            _ranking: oRule._ranking || 1.0\r\n          })\r\n        }\r\n        if (!exact && !oRule.exactOnly) {\r\n          var levenmatch = calcDistance(oRule.lowercaseword, lcString);\r\n\r\n/*\r\n          addCntRec(cntRec,\"calcDistance\", 1);\r\n          if(levenmatch < 50) {\r\n            addCntRec(cntRec,\"calcDistanceExp\", 1);\r\n          }\r\n          if(levenmatch < 40000) {\r\n            addCntRec(cntRec,\"calcDistanceBelow40k\", 1);\r\n          }\r\n          */\r\n          //if(oRule.lowercaseword === \"cosmos\") {\r\n          //  console.log(\"here ranking \" + levenmatch + \" \" + oRule.lowercaseword + \" \" + lcString);\r\n          //}\r\n          if (levenmatch >= Algol.Cutoff_WordMatch) { // levenCutoff) {\r\n            //console.log(\"found rec\");\r\n            addCntRec(cntRec,\"calcDistanceOk\", 1);\r\n            var rec = {\r\n              string: string,\r\n              rule : oRule,\r\n              matchedString: oRule.matchedString,\r\n              category: oRule.category,\r\n              _ranking: (oRule._ranking || 1.0) * levenPenalty(levenmatch),\r\n              levenmatch: levenmatch\r\n            };\r\n            debuglog(() =>\"\\n!CORO: fuzzy \" + (levenmatch).toFixed(3) + \" \" + rec._ranking.toFixed(3) + \"  \\\"\" + string + \"\\\"=\"  + oRule.lowercaseword  + \" => \" + oRule.matchedString + \"/\" + oRule.category + \"/\" + oRule.bitindex);\r\n            res.push(rec);\r\n          }\r\n        }\r\n        break;\r\n      case IFModel.EnumRuleType.REGEXP: {\r\n        if (debuglog.enabled) {\r\n          debuglog(JSON.stringify(\" here regexp\" + JSON.stringify(oRule, undefined, 2)))\r\n        }\r\n        var m = oRule.regexp.exec(string)\r\n        if (m) {\r\n          res.push({\r\n            string: string,\r\n            rule: oRule,\r\n            matchedString: (oRule.matchIndex !== undefined && m[oRule.matchIndex]) || string,\r\n            category: oRule.category,\r\n            _ranking: oRule._ranking || 1.0\r\n          })\r\n        }\r\n      }\r\n        break;\r\n      default:\r\n        throw new Error(\"unknown type\" + JSON.stringify(oRule, undefined, 2))\r\n    }\r\n}\r\n\r\n\r\nfunction addCntRec(cntRec : ICntRec, member : string, number : number) {\r\n  if((!cntRec) || (number === 0)) {\r\n    return;\r\n  }\r\n  cntRec[member] = (cntRec[member] || 0) + number;\r\n}\r\n\r\nexport function categorizeString(word: string, exact: boolean, oRules: Array<IFModel.mRule>,\r\n cntRec? : ICntRec): Array<IFMatch.ICategorizedString> {\r\n  // simply apply all rules\r\n  debuglogV(() => \"rules : \" + JSON.stringify(oRules, undefined, 2));\r\n\r\n  var lcString = word.toLowerCase();\r\n  var res: Array<IFMatch.ICategorizedString> = []\r\n  oRules.forEach(function (oRule) {\r\n    checkOneRule(word,lcString,exact,res,oRule,cntRec);\r\n  });\r\n  res.sort(sortByRank);\r\n  return res;\r\n}\r\n\r\n\r\n\r\nexport function categorizeSingleWordWithOffset(word: string, lcword : string, exact: boolean, oRules: Array<IFModel.mRule>,\r\n cntRec? : ICntRec): Array<IFMatch.ICategorizedStringRanged> {\r\n  // simply apply all rules\r\n  debuglogV(()=> \"rules : \" + JSON.stringify(oRules, undefined, 2));\r\n  var res: Array<IMatch.ICategorizedStringRanged> = []\r\n  oRules.forEach(function (oRule) {\r\n    checkOneRuleWithOffset(word,lcword,exact,res,oRule,cntRec);\r\n  });\r\n  debuglog(`CSWWO: got results for ${lcword}  ${res.length}`);\r\n  res.sort(sortByRank);\r\n  return res;\r\n}\r\n\r\n\r\nexport function postFilter(res : Array<IFMatch.ICategorizedString>) : Array<IFMatch.ICategorizedString> {\r\n  res.sort(sortByRank);\r\n  var bestRank = 0;\r\n  //console.log(\"\\npiltered \" + JSON.stringify(res));\r\n  if(debuglog.enabled) {\r\n    debuglog(\"preFilter : \\n\" + res.map(function(word,index) {\r\n      return `${index} ${word._ranking}  => \"${word.category}\" ${word.matchedString}`;\r\n    }).join(\"\\n\"));\r\n  }\r\n  var r = res.filter(function(resx,index) {\r\n    if(index === 0) {\r\n      bestRank = resx._ranking;\r\n      return true;\r\n    }\r\n    // 1-0.9 = 0.1\r\n    // 1- 0.93 = 0.7\r\n    // 1/7\r\n    var delta = bestRank / resx._ranking;\r\n    if((resx.matchedString === res[index-1].matchedString)\r\n      && (resx.category === res[index-1].category)\r\n      ) {\r\n        console.log('postfilter ignoring bitinidex!!!');\r\n      return false;\r\n    }\r\n    //console.log(\"\\n delta for \" + delta + \"  \" + resx._ranking);\r\n    if (resx.levenmatch && (delta > 1.03)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  });\r\n  if(debuglog.enabled) {\r\n      debuglog(`\\nfiltered ${r.length}/${res.length}` + JSON.stringify(r));\r\n  }\r\n  return r;\r\n}\r\n\r\n\r\nexport function dropLowerRankedEqualResult(res : Array<IFMatch.ICategorizedStringRanged>) : Array<IFMatch.ICategorizedStringRanged> {\r\n  res.sort(cmpByResultThenRank);\r\n  return res.filter(function(resx,index) {\r\n    var prior = res[index-1];\r\n    if( prior &&\r\n        !(resx.rule && resx.rule.range)\r\n     && !(res[index-1].rule && res[index-1].rule.range)\r\n     && (resx.matchedString === prior.matchedString)\r\n     && (resx.rule.bitindex === prior.rule.bitindex)\r\n     && (resx.rule.wordType === prior.rule.wordType)\r\n     && (resx.category === res[index-1].category)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  });\r\n}\r\n\r\n\r\nexport function postFilterWithOffset(res : Array<IFMatch.ICategorizedStringRanged>) : Array<IFMatch.ICategorizedStringRanged> {\r\n  // for filtering, we need to get *equal rule results close together\r\n  // =>\r\n  //\r\n\r\n  res.sort(sortByRank);\r\n  var bestRank = 0;\r\n  //console.log(\"\\npiltered \" + JSON.stringify(res));\r\n  if(debuglog.enabled) {\r\n    debuglog(\" preFilter : \\n\" + res.map(function(word) {\r\n      return ` ${word._ranking}  => \"${word.category}\" ${word.matchedString} `;\r\n    }).join(\"\\n\"));\r\n  }\r\n  var r = res.filter(function(resx,index) {\r\n    if(index === 0) {\r\n      bestRank = resx._ranking;\r\n      return true;\r\n    }\r\n    // 1-0.9 = 0.1\r\n    // 1- 0.93 = 0.7\r\n    // 1/7\r\n    var delta = bestRank / resx._ranking;\r\n    var prior = res[index-1];\r\n    if(\r\n        !(resx.rule && resx.rule.range)\r\n     && !(res[index-1].rule && res[index-1].rule.range)\r\n     && (resx.matchedString === prior.matchedString)\r\n     && (resx.rule.bitindex === prior.rule.bitindex)\r\n     && (resx.rule.wordType === prior.rule.wordType)\r\n     && (resx.category === res[index-1].category)) {\r\n      return false;\r\n    }\r\n    //console.log(\"\\n delta for \" + delta + \"  \" + resx._ranking);\r\n    if (resx.levenmatch && (delta > 1.03)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  });\r\n  r = dropLowerRankedEqualResult(res);\r\n  r.sort(sortByRankThenResult);\r\n\r\n  if(debuglog.enabled) {\r\n      debuglog(`\\nfiltered ${r.length}/${res.length}` + JSON.stringify(r));\r\n  }\r\n  return r;\r\n}\r\n\r\n\r\n\r\nexport function categorizeString2(word: string, exact: boolean,  rules : IFMatch.SplitRules\r\n  , cntRec? : ICntRec): Array<IFMatch.ICategorizedString> {\r\n  // simply apply all rules\r\n  if (debuglogM.enabled )  {\r\n    debuglogM(\"rules : \" + JSON.stringify(rules,undefined, 2));\r\n  }\r\n  var lcString = word.toLowerCase();\r\n  var res: Array<IFMatch.ICategorizedString> = [];\r\n  if (exact) {\r\n    var r = rules.wordMap[lcString];\r\n    if (r) {\r\n      r.rules.forEach(function(oRule) {\r\n        res.push({\r\n            string: word,\r\n            matchedString: oRule.matchedString,\r\n            category: oRule.category,\r\n            _ranking: oRule._ranking || 1.0\r\n          })\r\n     });\r\n    }\r\n    rules.nonWordRules.forEach(function (oRule) {\r\n      checkOneRule(word,lcString,exact,res,oRule,cntRec);\r\n    });\r\n    res.sort(sortByRank);\r\n    return res;\r\n  } else {\r\n    debuglog(\"categorize non exact\" + word + \" xx  \" + rules.allRules.length);\r\n    return postFilter(categorizeString(word, exact, rules.allRules, cntRec));\r\n  }\r\n}\r\n\r\n\r\nexport function categorizeWordInternalWithOffsets(word: string, lcword : string, exact: boolean,  rules : IMatch.SplitRules\r\n  , cntRec? :ICntRec): Array<IFMatch.ICategorizedStringRanged> {\r\n\r\n  debuglogM(\"categorize \" + lcword + \" with offset!!!!!!!!!!!!!!!!!\" + exact)\r\n  // simply apply all rules\r\n  if (debuglogV.enabled )  {\r\n    debuglogV(\"rules : \" + JSON.stringify(rules,undefined, 2));\r\n  }\r\n  var res: Array<IMatch.ICategorizedStringRanged> = [];\r\n  if (exact) {\r\n    var r = rules.wordMap[lcword];\r\n    if (r) {\r\n      debuglogM(debuglogM.enabled ? ` ....pushing n rules exact for ${lcword}:` + r.rules.length : '-');\r\n      debuglogM(debuglogM.enabled ? r.rules.map((r,index)=> '' + index + ' ' + JSON.stringify(r)).join(\"\\n\") : '-');\r\n      r.rules.forEach(function(oRule) {\r\n        res.push({\r\n            string: word,\r\n            matchedString: oRule.matchedString,\r\n            category: oRule.category,\r\n            rule: oRule,\r\n            _ranking: oRule._ranking || 1.0\r\n          })\r\n     });\r\n    }\r\n    rules.nonWordRules.forEach(function (oRule) {\r\n      checkOneRuleWithOffset(word,lcword, exact,res,oRule,cntRec);\r\n    });\r\n    res = postFilterWithOffset(res);\r\n    debuglog(()=>\"here results exact for \" + word + \" res \" + res.length);\r\n    debuglogM(()=>\"here results exact for \" + word + \" res \" + res.length);\r\n    res.sort(sortByRank);\r\n    return res;\r\n  } else {\r\n    debuglog(\"categorize non exact \\\"\" + word + \"\\\"    \" + rules.allRules.length);\r\n    var rr = categorizeSingleWordWithOffset(word,lcword, exact, rules.allRules, cntRec);\r\n    //debulogM(\"fuzzy res \" + JSON.stringify(rr));\r\n    return postFilterWithOffset(rr);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n *\r\n * Options may be {\r\n * matchothers : true,  => only rules where all others match are considered\r\n * augment : true,\r\n * override : true }  =>\r\n *\r\n */\r\nexport function matchWord(oRule: IFModel.IRule, context: IFMatch.context, options?: IMatchOptions) {\r\n  if (context[oRule.key] === undefined) {\r\n    return undefined;\r\n  }\r\n  var s1 = context[oRule.key].toLowerCase()\r\n  var s2 = oRule.word.toLowerCase();\r\n  options = options || {}\r\n  var delta = compareContext(context, oRule.follows, oRule.key)\r\n  if(debuglog.enabled) {\r\n    debuglog(JSON.stringify(delta));\r\n    debuglog(JSON.stringify(options));\r\n  }\r\n  if (options.matchothers && (delta.different > 0)) {\r\n    return undefined\r\n  }\r\n  var c: number = calcDistance(s2, s1);\r\n  if(debuglog.enabled) {\r\n    debuglog(\" s1 <> s2 \" + s1 + \"<>\" + s2 + \"  =>: \" + c);\r\n  }\r\n  if (c > 0.80) {\r\n    var res = AnyObject.assign({}, oRule.follows) as any;\r\n    res = AnyObject.assign(res, context);\r\n    if (options.override) {\r\n      res = AnyObject.assign(res, oRule.follows);\r\n    }\r\n    // force key property\r\n    // console.log(' objectcategory', res['systemObjectCategory']);\r\n    res[oRule.key] = oRule.follows[oRule.key] || res[oRule.key];\r\n    res._weight = AnyObject.assign({}, res._weight);\r\n    res._weight[oRule.key] = c;\r\n    Object.freeze(res);\r\n    if ( debuglog.enabled) {\r\n      debuglog('Found one' + JSON.stringify(res, undefined, 2));\r\n    }\r\n    return res;\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function extractArgsMap(match: Array<string>, argsMap: { [key: number]: string }): IFMatch.context {\r\n  var res = {} as IFMatch.context;\r\n  if (!argsMap) {\r\n    return res;\r\n  }\r\n  Object.keys(argsMap).forEach(function (iKey) {\r\n    var value = match[iKey]\r\n    var key = argsMap[iKey];\r\n    if ((typeof value === \"string\") && value.length > 0) {\r\n      res[key] = value\r\n    }\r\n  }\r\n  );\r\n  return res;\r\n}\r\n\r\nexport const RankWord = {\r\n  hasAbove: function (lst: Array<IFMatch.ICategorizedString>, border: number): boolean {\r\n    return !lst.every(function (oMember) {\r\n      return (oMember._ranking < border);\r\n    });\r\n  },\r\n\r\n  takeFirstN: function<T extends IFMatch.ICategorizedString> (lst: Array<T>, n: number): Array<T> {\r\n    var lastRanking = 1.0;\r\n    var cntRanged = 0;\r\n    return lst.filter(function (oMember, iIndex) {\r\n    var isRanged = !!(oMember[\"rule\"] && oMember[\"rule\"].range);\r\n    if(isRanged) {\r\n      cntRanged += 1;\r\n      return true;\r\n    }\r\n    if (((iIndex - cntRanged) < n) || (oMember._ranking === lastRanking))  {\r\n        lastRanking = oMember._ranking;\r\n        return true;\r\n      }\r\n      return false;\r\n    });\r\n  },\r\n  takeAbove : function<T extends IFMatch.ICategorizedString> (lst: Array<T>, border: number): Array<T> {\r\n    return lst.filter(function (oMember) {\r\n      return (oMember._ranking >= border);\r\n    });\r\n  }\r\n\r\n};\r\n\r\n/*\r\nvar exactLen = 0;\r\nvar fuzzyLen = 0;\r\nvar fuzzyCnt = 0;\r\nvar exactCnt = 0;\r\nvar totalCnt = 0;\r\nvar totalLen = 0;\r\nvar retainedCnt = 0;\r\n\r\nexport function resetCnt() {\r\n  exactLen = 0;\r\n  fuzzyLen = 0;\r\n  fuzzyCnt = 0;\r\n  exactCnt = 0;\r\n  totalCnt = 0;\r\n  totalLen = 0;\r\n  retainedCnt = 0;\r\n}\r\n*/\r\n\r\nexport function categorizeWordWithRankCutoff(sWordGroup: string, splitRules : IMatch.SplitRules , cntRec? : ICntRec ): Array<IFMatch.ICategorizedString> {\r\n  var seenIt = categorizeString2(sWordGroup, true, splitRules, cntRec);\r\n  //totalCnt += 1;\r\n  // exactLen += seenIt.length;\r\n  addCntRec(cntRec, 'cntCatExact', 1);\r\n  addCntRec(cntRec, 'cntCatExactRes', seenIt.length);\r\n\r\n  if (RankWord.hasAbove(seenIt, 0.8)) {\r\n    if(cntRec) {\r\n      addCntRec(cntRec, 'exactPriorTake', seenIt.length)\r\n    }\r\n    seenIt = RankWord.takeAbove(seenIt, 0.8);\r\n    if(cntRec) {\r\n      addCntRec(cntRec, 'exactAfterTake', seenIt.length)\r\n    }\r\n   // exactCnt += 1;\r\n  } else {\r\n    seenIt = categorizeString2(sWordGroup, false, splitRules, cntRec);\r\n    addCntRec(cntRec, 'cntNonExact', 1);\r\n    addCntRec(cntRec, 'cntNonExactRes', seenIt.length);\r\n  //  fuzzyLen += seenIt.length;\r\n  //  fuzzyCnt += 1;\r\n  }\r\n // totalLen += seenIt.length;\r\n  seenIt = RankWord.takeFirstN(seenIt, Algol.Top_N_WordCategorizations);\r\n // retainedCnt += seenIt.length;\r\n  return seenIt;\r\n}\r\n\r\n/* if we have a  \"Run like the Wind\"\r\n  an a user type fun like  a Rind , and Rind is an exact match,\r\n  we will not start looking for the long sentence\r\n\r\n  this is to be fixed by \"spreading\" the range indication accross very similar words in the vincinity of the\r\n  target words\r\n*/\r\n\r\nexport function categorizeWordWithOffsetWithRankCutoff(sWordGroup: string, splitRules : IMatch.SplitRules, cntRec? : ICntRec ): Array<IFMatch.ICategorizedStringRanged> {\r\n  var sWordGroupLC = sWordGroup.toLowerCase();\r\n  var seenIt = categorizeWordInternalWithOffsets(sWordGroup, sWordGroupLC, true, splitRules, cntRec);\r\n  //console.log(\"SEENIT\" + JSON.stringify(seenIt));\r\n  //totalCnt += 1;\r\n  // exactLen += seenIt.length;\r\n  //console.log(\"first run exact \" + JSON.stringify(seenIt));\r\n  addCntRec(cntRec, 'cntCatExact', 1);\r\n  addCntRec(cntRec, 'cntCatExactRes', seenIt.length);\r\n\r\n  if (RankWord.hasAbove(seenIt, 0.8)) {\r\n    if(cntRec) {\r\n      addCntRec(cntRec, 'exactPriorTake', seenIt.length)\r\n    }\r\n    seenIt = RankWord.takeAbove(seenIt, 0.8);\r\n    if(cntRec) {\r\n      addCntRec(cntRec, 'exactAfterTake', seenIt.length)\r\n    }\r\n   // exactCnt += 1;\r\n  } else {\r\n    seenIt = categorizeWordInternalWithOffsets(sWordGroup, sWordGroupLC, false, splitRules, cntRec);\r\n    addCntRec(cntRec, 'cntNonExact', 1);\r\n    addCntRec(cntRec, 'cntNonExactRes', seenIt.length);\r\n  //  fuzzyLen += seenIt.length;\r\n  //  fuzzyCnt += 1;\r\n  }\r\n  // totalLen += seenIt.length;\r\n  debuglog(debuglog.enabled? ( `${seenIt.length} with ${seenIt.reduce( (prev,obj) => prev + (obj.rule.range ? 1 : 0),0)} ranged !`): '-');\r\n//  var cntRanged = seenIt.reduce( (prev,obj) => prev + (obj.rule.range ? 1 : 0),0);\r\n//  console.log(`*********** ${seenIt.length} with ${cntRanged} ranged !`);\r\n\r\n  seenIt = RankWord.takeFirstN(seenIt, Algol.Top_N_WordCategorizations);\r\n // retainedCnt += seenIt.length;\r\n  //console.log(\"final res of categorizeWordWithOffsetWithRankCutoff\" + JSON.stringify(seenIt));\r\n\r\n  return seenIt;\r\n}\r\n\r\n\r\nexport function categorizeWordWithOffsetWithRankCutoffSingle(word: string, rule: IFModel.mRule): IFMatch.ICategorizedStringRanged {\r\n  var lcword = word.toLowerCase();\r\n\r\n  if(lcword === rule.lowercaseword) {\r\n    return {\r\n            string: word,\r\n            matchedString: rule.matchedString,\r\n            category: rule.category,\r\n            rule: rule,\r\n            _ranking: rule._ranking || 1.0\r\n          };\r\n  }\r\n\r\n  var res: Array<IMatch.ICategorizedStringRanged> = []\r\n  checkOneRuleWithOffset(word,lcword,false,res,rule);\r\n  debuglog(\"catWWOWRCS \" + lcword);\r\n  if(res.length) {\r\n    return res[0];\r\n  }\r\n  return undefined;\r\n}\r\n\r\n\r\n\r\n/*\r\nexport function dumpCnt() {\r\n  console.log(`\r\nexactLen = ${exactLen};\r\nexactCnt = ${exactCnt};\r\nfuzzyLen = ${fuzzyLen};\r\nfuzzyCnt = ${fuzzyCnt};\r\ntotalCnt = ${totalCnt};\r\ntotalLen = ${totalLen};\r\nretainedLen = ${retainedCnt};\r\n  `);\r\n}\r\n*/\r\n\r\n/*\r\nexport function filterRemovingUncategorizedSentence(oSentence: IFMatch.ICategorizedString[][]): boolean {\r\n  return oSentence.every(function (oWordGroup) {\r\n    return (oWordGroup.length > 0);\r\n  });\r\n}\r\n\r\n\r\n\r\nexport function filterRemovingUncategorized(arr: IFMatch.ICategorizedString[][][]): IFMatch.ICategorizedString[][][] {\r\n  return arr.filter(function (oSentence) {\r\n    return filterRemovingUncategorizedSentence(oSentence);\r\n  });\r\n}\r\n*/\r\n\r\nexport function categorizeAWord(sWordGroup: string, rules: IMatch.SplitRules, sentence: string, words: { [key: string]: Array<IFMatch.ICategorizedString>},\r\ncntRec ? : ICntRec ) : IMatch.ICategorizedString[] {\r\n  var seenIt = words[sWordGroup];\r\n  if (seenIt === undefined) {\r\n    seenIt = categorizeWordWithRankCutoff(sWordGroup, rules, cntRec);\r\n    utils.deepFreeze(seenIt);\r\n    words[sWordGroup] = seenIt;\r\n  }\r\n  if (!seenIt || seenIt.length === 0) {\r\n    logger(\"***WARNING: Did not find any categorization for \\\"\" + sWordGroup + \"\\\" in sentence \\\"\"\r\n      + sentence + \"\\\"\");\r\n    if (sWordGroup.indexOf(\" \") <= 0) {\r\n      debuglog(\"***WARNING: Did not find any categorization for primitive (!)\" + sWordGroup);\r\n    }\r\n    debuglog(\"***WARNING: Did not find any categorization for \" + sWordGroup);\r\n    if (!seenIt) {\r\n      throw new Error(\"Expecting emtpy list, not undefined for \\\"\" + sWordGroup + \"\\\"\")\r\n    }\r\n    words[sWordGroup] = []\r\n    return [];\r\n  }\r\n  return utils.cloneDeep(seenIt);\r\n}\r\n\r\n\r\n/**\r\n * Given a  string, break it down into components,\r\n * [['A', 'B'], ['A B']]\r\n *\r\n * then categorizeWords\r\n * returning\r\n *\r\n * [ [[ { category: 'systemId', word : 'A'},\r\n *      { category: 'otherthing', word : 'A'}\r\n *    ],\r\n *    // result of B\r\n *    [ { category: 'systemId', word : 'B'},\r\n *      { category: 'otherthing', word : 'A'}\r\n *      { category: 'anothertryp', word : 'B'}\r\n *    ]\r\n *   ],\r\n * ]]]\r\n *\r\n *\r\n *\r\n */\r\nexport function analyzeString(sString: string, rules: IMatch.SplitRules,\r\n  words?: { [key: string]: Array<IFMatch.ICategorizedString> })\r\n  : [ [ IMatch.ICategorizedString[]] ]\r\n   {\r\n  var cnt = 0;\r\n  var fac = 1;\r\n  var u = breakdown.breakdownString(sString, Algol.MaxSpacesPerCombinedWord);\r\n  if(debuglog.enabled) {\r\n    debuglog(\"here breakdown\" + JSON.stringify(u));\r\n  }\r\n  //console.log(JSON.stringify(u));\r\n  words = words || {};\r\n  debugperf('this many known words: ' + Object.keys(words).length);\r\n  var res = [] as [[ IMatch.ICategorizedString[]] ];\r\n  var cntRec = {};\r\n  u.forEach(function (aBreakDownSentence) {\r\n      var categorizedSentence = [] as [ IMatch.ICategorizedString[] ];\r\n      var isValid = aBreakDownSentence.every(function (sWordGroup: string, index : number) {\r\n        var seenIt = categorizeAWord(sWordGroup, rules, sString, words, cntRec);\r\n        if(seenIt.length === 0) {\r\n          return false;\r\n        }\r\n        categorizedSentence[index] = seenIt;\r\n        cnt = cnt + seenIt.length;\r\n        fac = fac * seenIt.length;\r\n        return true;\r\n      });\r\n      if(isValid) {\r\n        res.push(categorizedSentence);\r\n      }\r\n  });\r\n  debuglog(\" sentences \" + u.length + \" matches \" + cnt + \" fac: \" + fac);\r\n  if(debuglog.enabled && u.length) {\r\n    debuglog(\"first match \"+ JSON.stringify(u,undefined,2));\r\n  }\r\n  debugperf(\" sentences \" + u.length + \" / \" + res.length +  \" matches \" + cnt + \" fac: \" + fac + \" rec : \" + JSON.stringify(cntRec,undefined,2));\r\n  return res;\r\n}\r\n\r\n\r\nexport function categorizeAWordWithOffsets(sWordGroup: string, rules: IMatch.SplitRules, sentence: string, words: { [key: string]: Array<IFMatch.ICategorizedString>},\r\ncntRec ? : ICntRec ) : IMatch.ICategorizedStringRanged[] {\r\n  var seenIt = words[sWordGroup];\r\n  if (seenIt === undefined) {\r\n    seenIt = categorizeWordWithOffsetWithRankCutoff(sWordGroup, rules, cntRec);\r\n    utils.deepFreeze(seenIt);\r\n    words[sWordGroup] = seenIt;\r\n  }\r\n  if (!seenIt || seenIt.length === 0) {\r\n    logger(\"***WARNING: Did not find any categorization for \\\"\" + sWordGroup + \"\\\" in sentence \\\"\"\r\n      + sentence + \"\\\"\");\r\n    if (sWordGroup.indexOf(\" \") <= 0) {\r\n      debuglog(\"***WARNING: Did not find any categorization for primitive (!)\" + sWordGroup);\r\n    }\r\n    debuglog(\"***WARNING: Did not find any categorization for \" + sWordGroup);\r\n    if (!seenIt) {\r\n      throw new Error(\"Expecting emtpy list, not undefined for \\\"\" + sWordGroup + \"\\\"\")\r\n    }\r\n    words[sWordGroup] = []\r\n    return [];\r\n  }\r\n  return utils.cloneDeep(seenIt);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n[ [a,b], [c,d]]\r\n\r\n00 a\r\n01 b\r\n10 c\r\n11 d\r\n12 c\r\n*/\r\n\r\n\r\nconst clone = utils.cloneDeep;\r\n\r\n\r\nfunction copyVecMembers(u) {\r\n  var i = 0;\r\n  for(i = 0; i < u.length; ++i) {\r\n    u[i] = clone(u[i]);\r\n  }\r\n  return u;\r\n}\r\n// we can replicate the tail or the head,\r\n// we replicate the tail as it is smaller.\r\n\r\n// [a,b,c ]\r\n\r\nexport function expandMatchArr(deep: Array<Array<any>>): Array<Array<any>> {\r\n  var a = [];\r\n  var line = [];\r\n  debuglog(debuglog.enabled ? JSON.stringify(deep) : '-');\r\n  deep.forEach(function (uBreakDownLine, iIndex: number) {\r\n    line[iIndex] = [];\r\n    uBreakDownLine.forEach(function (aWordGroup, wgIndex: number) {\r\n      line[iIndex][wgIndex] = [];\r\n      aWordGroup.forEach(function (oWordVariant, iWVIndex: number) {\r\n        line[iIndex][wgIndex][iWVIndex] = oWordVariant;\r\n      });\r\n    });\r\n  })\r\n  debuglog(debuglog.enabled ? JSON.stringify(line) : '-');\r\n  var res = [];\r\n  var nvecs = [];\r\n  for (var i = 0; i < line.length; ++i) {\r\n    var vecs = [[]];\r\n    var nvecs = [];\r\n    var rvec = [];\r\n    for (var k = 0; k < line[i].length; ++k) { // wordgroup k\r\n      //vecs is the vector of all so far seen variants up to k wgs.\r\n      var nextBase = [];\r\n      for (var l = 0; l < line[i][k].length; ++l) { // for each variant\r\n        //debuglog(\"vecs now\" + JSON.stringify(vecs));\r\n        nvecs = []; //vecs.slice(); // copy the vec[i] base vector;\r\n        //debuglog(\"vecs copied now\" + JSON.stringify(nvecs));\r\n        for (var u = 0; u < vecs.length; ++u) {\r\n          nvecs[u] = vecs[u].slice(); //\r\n          nvecs[u] = copyVecMembers(nvecs[u]);\r\n          // debuglog(\"copied vecs[\"+ u+\"]\" + JSON.stringify(vecs[u]));\r\n          nvecs[u].push(\r\n            clone(line[i][k][l])); // push the lth variant\r\n          // debuglog(\"now nvecs \" + nvecs.length + \" \" + JSON.stringify(nvecs));\r\n        }\r\n        //   debuglog(\" at     \" + k + \":\" + l + \" nextbase >\" + JSON.stringify(nextBase))\r\n        //   debuglog(\" append \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nvecs))\r\n        nextBase = nextBase.concat(nvecs);\r\n        //   debuglog(\"  result \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nextBase))\r\n      } //constru\r\n      //  debuglog(\"now at \" + k + \":\" + l + \" >\" + JSON.stringify(nextBase))\r\n      vecs = nextBase;\r\n    }\r\n    debuglogV(debuglogV.enabled ? (\"APPENDING TO RES\" + i + \":\" + l + \" >\" + JSON.stringify(nextBase)) : '-');\r\n    res = res.concat(vecs);\r\n  }\r\n  return res;\r\n}\r\n\r\n\r\n/**\r\n * Calculate a weight factor for a given distance and\r\n * category\r\n * @param {integer} dist distance in words\r\n * @param {string} category category to use\r\n * @returns {number} a distance factor >= 1\r\n *  1.0 for no effect\r\n */\r\nexport function reinforceDistWeight(dist: number, category: string): number {\r\n  var abs = Math.abs(dist);\r\n  return 1.0 + (Algol.aReinforceDistWeight[abs] || 0);\r\n}\r\n\r\n/**\r\n * Given a sentence, extact categories\r\n */\r\nexport function extractCategoryMap(oSentence: Array<IFMatch.IWord>): { [key: string]: Array<{ pos: number }> } {\r\n  var res = {};\r\n  debuglog(debuglog.enabled ? ('extractCategoryMap ' + JSON.stringify(oSentence)) : '-');\r\n  oSentence.forEach(function (oWord, iIndex) {\r\n    if (oWord.category === IFMatch.CAT_CATEGORY) {\r\n      res[oWord.matchedString] = res[oWord.matchedString] || [];\r\n      res[oWord.matchedString].push({ pos: iIndex });\r\n    }\r\n  });\r\n  utils.deepFreeze(res);\r\n  return res;\r\n}\r\n\r\nexport function reinForceSentence(oSentence) {\r\n  \"use strict\";\r\n  var oCategoryMap = extractCategoryMap(oSentence);\r\n  oSentence.forEach(function (oWord, iIndex) {\r\n    var m = oCategoryMap[oWord.category] || [];\r\n    m.forEach(function (oPosition: { pos: number }) {\r\n      \"use strict\";\r\n      oWord.reinforce = oWord.reinforce || 1;\r\n      var boost = reinforceDistWeight(iIndex - oPosition.pos, oWord.category);\r\n      oWord.reinforce *= boost;\r\n      oWord._ranking *= boost;\r\n    });\r\n  });\r\n  oSentence.forEach(function (oWord, iIndex) {\r\n    if (iIndex > 0 ) {\r\n      if (oSentence[iIndex-1].category === \"meta\"  && (oWord.category === oSentence[iIndex-1].matchedString) ) {\r\n        oWord.reinforce = oWord.reinforce || 1;\r\n        var boost = reinforceDistWeight(1, oWord.category);\r\n        oWord.reinforce *= boost;\r\n        oWord._ranking *= boost;\r\n      }\r\n    }\r\n  });\r\n  return oSentence;\r\n}\r\n\r\n\r\nimport * as Sentence from './sentence';\r\n\r\nexport function reinForce(aCategorizedArray) {\r\n  \"use strict\";\r\n  aCategorizedArray.forEach(function (oSentence) {\r\n    reinForceSentence(oSentence);\r\n  })\r\n  aCategorizedArray.sort(Sentence.cmpRankingProduct);\r\n  if(debuglog.enabled) {\r\n    debuglog(\"after reinforce\" + aCategorizedArray.map(function (oSentence) {\r\n      return Sentence.rankingProduct(oSentence) + \":\" + JSON.stringify(oSentence);\r\n    }).join(\"\\n\"));\r\n  }\r\n  return aCategorizedArray;\r\n}\r\n\r\n\r\n/// below may no longer be used\r\n\r\nexport function matchRegExp(oRule: IFModel.IRule, context: IFMatch.context, options?: IMatchOptions) {\r\n  if (context[oRule.key] === undefined) {\r\n    return undefined;\r\n  }\r\n  var sKey = oRule.key;\r\n  var s1 = context[oRule.key].toLowerCase()\r\n  var reg = oRule.regexp;\r\n\r\n  var m = reg.exec(s1);\r\n  if(debuglogV.enabled) {\r\n    debuglogV(\"applying regexp: \" + s1 + \" \" + JSON.stringify(m));\r\n  }\r\n  if (!m) {\r\n    return undefined;\r\n  }\r\n  options = options || {}\r\n  var delta = compareContext(context, oRule.follows, oRule.key)\r\n  if (debuglogV.enabled) {\r\n    debuglogV(JSON.stringify(delta));\r\n    debuglogV(JSON.stringify(options));\r\n  }\r\n  if (options.matchothers && (delta.different > 0)) {\r\n    return undefined\r\n  }\r\n  var oExtractedContext = extractArgsMap(m, oRule.argsMap);\r\n  if (debuglogV.enabled) {\r\n    debuglogV(\"extracted args \" + JSON.stringify(oRule.argsMap));\r\n    debuglogV(\"match \" + JSON.stringify(m));\r\n    debuglogV(\"extracted args \" + JSON.stringify(oExtractedContext));\r\n  }\r\n  var res = AnyObject.assign({}, oRule.follows) as any;\r\n  res = AnyObject.assign(res, oExtractedContext);\r\n  res = AnyObject.assign(res, context);\r\n  if (oExtractedContext[sKey] !== undefined) {\r\n    res[sKey] = oExtractedContext[sKey];\r\n  }\r\n  if (options.override) {\r\n    res = AnyObject.assign(res, oRule.follows);\r\n    res = AnyObject.assign(res, oExtractedContext)\r\n  }\r\n  Object.freeze(res);\r\n  debuglog(debuglog.enabled ? ('Found one' + JSON.stringify(res, undefined, 2)) : '-');\r\n  return res;\r\n}\r\n\r\nexport function sortByWeight(sKey: string, oContextA: IFMatch.context, oContextB: IFMatch.context): number {\r\n  if (debuglog.enabled) {\r\n    debuglogV('sorting: ' + sKey + 'invoked with\\n 1:' + JSON.stringify(oContextA, undefined, 2) +\r\n    \" vs \\n 2:\" + JSON.stringify(oContextB, undefined, 2));\r\n  }\r\n  var rankingA: number = parseFloat(oContextA[\"_ranking\"] || \"1\");\r\n  var rankingB: number = parseFloat(oContextB[\"_ranking\"] || \"1\");\r\n  if (rankingA !== rankingB) {\r\n    if(debuglog.enabled) {\r\n      debuglog(\" rankin delta\" + 100 * (rankingB - rankingA));\r\n    }\r\n    return 100 * (rankingB - rankingA)\r\n  }\r\n\r\n  var weightA = oContextA[\"_weight\"] && oContextA[\"_weight\"][sKey] || 0;\r\n  var weightB = oContextB[\"_weight\"] && oContextB[\"_weight\"][sKey] || 0;\r\n  return +(weightB - weightA);\r\n}\r\n\r\n\r\n// Word, Synonym, Regexp / ExtractionRule\r\n\r\nexport function augmentContext1(context: IFMatch.context, oRules: Array<IFModel.IRule>, options: IMatchOptions): Array<IFMatch.context> {\r\n  var sKey = oRules[0].key;\r\n  // check that rule\r\n  if (debuglog.enabled) {\r\n    // check consistency\r\n    oRules.every(function (iRule) {\r\n      if (iRule.key !== sKey) {\r\n        throw new Error(\"Inhomogenous keys in rules, expected \" + sKey + \" was \" + JSON.stringify(iRule));\r\n      }\r\n      return true;\r\n    });\r\n  }\r\n\r\n  // look for rules which match\r\n  var res = oRules.map(function (oRule) {\r\n    // is this rule applicable\r\n    switch (oRule.type) {\r\n      case IFModel.EnumRuleType.WORD:\r\n        return matchWord(oRule, context, options)\r\n      case IFModel.EnumRuleType.REGEXP:\r\n        return matchRegExp(oRule, context, options);\r\n      //   case \"Extraction\":\r\n      //     return matchExtraction(oRule,context);\r\n    }\r\n    return undefined\r\n  }).filter(function (ores) {\r\n    return !!ores\r\n  }).sort(\r\n    sortByWeight.bind(this, sKey)\r\n    );\r\n    //debuglog(\"hassorted\" + JSON.stringify(res,undefined,2));\r\n  return res;\r\n  // Object.keys().forEach(function (sKey) {\r\n  // });\r\n}\r\n\r\nexport function augmentContext(context: IFMatch.context, aRules: Array<IFModel.IRule>): Array<IFMatch.context> {\r\n\r\n  var options1: IMatchOptions = {\r\n    matchothers: true,\r\n    override: false\r\n  } as IMatchOptions;\r\n\r\n  var aRes = augmentContext1(context, aRules, options1)\r\n\r\n  if (aRes.length === 0) {\r\n    var options2: IMatchOptions = {\r\n      matchothers: false,\r\n      override: true\r\n    } as IMatchOptions;\r\n    aRes = augmentContext1(context, aRules, options2);\r\n  }\r\n  return aRes;\r\n}\r\n\r\n/*\r\nexport function insertOrdered(result: Array<IFMatch.context>, iInsertedMember: IFMatch.context, limit: number): Array<IFMatch.context> {\r\n  // TODO: use some weight\r\n  if (result.length < limit) {\r\n    result.push(iInsertedMember)\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\n\r\nexport function takeTopN(arr: Array<Array<IFMatch.context>>): Array<IFMatch.context> {\r\n  var u = arr.filter(function (innerArr) { return innerArr.length > 0 })\r\n\r\n  var res = [];\r\n  // shift out the top ones\r\n  u = u.map(function (iArr) {\r\n    var top = iArr.shift();\r\n    res = insertOrdered(res, top, 5)\r\n    return iArr\r\n  }).filter(function (innerArr: Array<IFMatch.context>): boolean { return innerArr.length > 0 });\r\n  // as Array<Array<IFMatch.context>>\r\n  return res;\r\n}\r\n*/\r\n\r\n/*\r\nvar rm;\r\n\r\nfunction getRMOnce() {\r\n  if (!rm) {\r\n    rm = inputFilterRules.getRuleMap()\r\n  }\r\n  return rm;\r\n}\r\n\r\nexport function applyRules(context: IFMatch.context): Array<IFMatch.context> {\r\n  var bestN: Array<IFMatch.context> = [context];\r\n  inputFilterRules.oKeyOrder.forEach(function (sKey: string) {\r\n    var bestNext: Array<Array<IFMatch.context>> = [];\r\n    bestN.forEach(function (oContext: IFMatch.context) {\r\n      if (oContext[sKey]) {\r\n        debuglog('** applying rules for ' + sKey)\r\n        var res = augmentContext(oContext, getRMOnce()[sKey] || [])\r\n        debuglog(debuglog.enabled ? ('** result for ' + sKey + ' = ' + JSON.stringify(res, undefined, 2)): '-');\r\n        bestNext.push(res || [])\r\n      } else {\r\n        // rule not relevant\r\n        bestNext.push([oContext]);\r\n      }\r\n    })\r\n    bestN = takeTopN(bestNext);\r\n  });\r\n  return bestN\r\n}\r\n\r\n\r\nexport function applyRulesPickFirst(context: IFMatch.context): IFMatch.context {\r\n  var r = applyRules(context);\r\n  return r && r[0];\r\n}\r\n\r\n*/\r\n\r\n/**\r\n * Decide whether to requery for a contet\r\n */\r\n//export function decideOnReQuery(context: IFMatch.context): Array<IFMatch.context> {\r\n//  return []\r\n//}\r\n"],"sourceRoot":"ABC"}