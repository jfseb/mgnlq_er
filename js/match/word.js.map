{"version":3,"sources":["../src/match/word.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;AAUU,QAAA,QAAQ,GAAG;IACtB,YAAY,EAAI,UAAU;IAC1B,UAAU,EAAI,QAAQ;IACtB,UAAU,EAAG,QAAQ;IACrB,QAAQ,EAAG,MAAM;IACjB,YAAY,EAAG,CAAC,QAAQ,CAAC;IACzB,QAAQ,EAAG,UAAS,SAAkB;QACpC,OAAO,SAAS,KAAK,gBAAQ,CAAC,UAAU,CAAC;IAC3C,CAAC;IACD,UAAU,EAAG,UAAS,SAAkB;QACtC,OAAO,SAAS,KAAK,gBAAQ,CAAC,YAAY,CAAC;IAC7C,CAAC;IACD,QAAQ,EAAE,UAAS,SAAkB;QACnC,OAAO,gBAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACvD,CAAC;CACF,CAAA;AAEY,QAAA,IAAI,GAAG;IAClB,QAAQ,EAAG,UAAS,IAAmB;QACrC,OAAO,IAAI,CAAC,QAAQ,KAAK,SAAS,IAAI,gBAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACzE,CAAC;IACD,UAAU,EAAG,UAAS,IAAmB;QACvC,OAAO,gBAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC5C,CAAC;IACD,QAAQ,EAAG,UAAS,IAAmB;QACrC,IAAG,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAClC,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAC,gBAAgB,CAAC;SACpD;QACD,OAAO,gBAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC1C,CAAC;CACF,CAAC;AAGW,QAAA,QAAQ,GAAG;IACtB,YAAY,EAAI,UAAU;IAC1B,UAAU,EAAI,QAAQ;IACtB,UAAU,EAAG,QAAQ;IACrB,QAAQ,EAAG,MAAM;IACjB,YAAY,EAAG,CAAC,QAAQ,CAAC;IACzB,QAAQ,EAAG,UAAS,SAAkB;QACpC,OAAO,SAAS,KAAK,gBAAQ,CAAC,UAAU,CAAC;IAC3C,CAAC;IACD,UAAU,EAAG,UAAS,SAAkB;QACtC,OAAO,SAAS,KAAK,gBAAQ,CAAC,YAAY,CAAC;IAC7C,CAAC;IACD,QAAQ,EAAE,UAAS,SAAkB;QACnC,OAAO,gBAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACvD,CAAC;CACF,CAAA","file":"word.js","sourcesContent":["/**\n * @file word\n * @module jfseb.fdevstart.sentence\n * @copyright (c) Gerd Forstmann\n *\n * Word specific qualifications,\n *\n * These functions expose parf the underlying model,\n * e.g.\n * Match a tool record on a sentence,\n *\n * This will unify matching required and optional category words\n * with the requirements of the tool.\n *\n */\n\n// <reference path=\"../../lib/node-4.d.ts\" />\n\n// import * as debug from 'debug';\n\n// import * as utils from '../utils/utils';\n\nimport * as IMatch from './iferbase';\n\nexport const Category = {\n  CAT_CATEGORY :  \"category\",\n  CAT_DOMAIN :  \"domain\",\n  CAT_FILLER : \"filler\",\n  CAT_TOOL : \"tool\",\n  _aCatFillers : [\"filler\"],\n  isDomain : function(sCategory : string )  : boolean{\n    return sCategory === Category.CAT_DOMAIN;\n  },\n  isCategory : function(sCategory : string )  : boolean{\n    return sCategory === Category.CAT_CATEGORY;\n  },\n  isFiller: function(sCategory : string) : boolean {\n    return Category._aCatFillers.indexOf(sCategory) >= 0;\n  }\n}\n\nexport const Word = {\n  isFiller : function(word : IMatch.IWord) : boolean {\n    return word.category === undefined || Category.isFiller(word.category);\n  },\n  isCategory : function(word : IMatch.IWord) : boolean {\n    return Category.isCategory(word.category);\n  },\n  isDomain : function(word : IMatch.IWord) : boolean {\n    if(word.rule && word.rule.wordType) {\n      return word.rule.wordType === 'D' /* WORDTYPE_D */;\n    }\n    return Category.isDomain(word.category);\n  }\n};\n\n\nexport const WordType = {\n  CAT_CATEGORY :  \"category\",\n  CAT_DOMAIN :  \"domain\",\n  CAT_FILLER : \"filler\",\n  CAT_TOOL : \"tool\",\n  _aCatFillers : [\"filler\"],\n  isDomain : function(sCategory : string )  : boolean{\n    return sCategory === Category.CAT_DOMAIN;\n  },\n  isCategory : function(sCategory : string )  : boolean{\n    return sCategory === Category.CAT_CATEGORY;\n  },\n  isFiller: function(sCategory : string) : boolean {\n    return Category._aCatFillers.indexOf(sCategory) >= 0;\n  }\n}\n"]}