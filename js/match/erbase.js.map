{"version":3,"sources":["/projects/nodejs/botbuilder/abot_stringdist/src/../src/match/erbase.ts"],"names":[],"mappings":"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","file":"match/erbase.js","sourcesContent":["/**\n *\n * @module jfseb.erbase\n * @file erbase\n * @copyright (c) 2016 Gerd Forstmann\n *\n * Basic domain based entity recognition\n *\n */\n\n\nimport * as WordMatch from './inputFilter';\n\nimport * as debug from 'debug';\n\n\n\nvar debuglog = debug('erbase');\nvar debuglogV = debug('erbase');\nvar perflog = debug('perf');\n\nimport { BreakDown as breakdown}  from 'mgnlq_model';\nimport * as ERError from './ererror';\n\nconst AnyObject = <any>Object;\n\nexport function mockDebug(o) {\n  debuglog = o;\n  debuglogV = o;\n  perflog = o;\n}\n\n\nimport * as utils from 'abot_utils';\n\nimport * as IFErBase from './iferbase';\nimport { IFModel  as IMatch}  from 'mgnlq_model';\nimport { IFModel  as IFModel}  from 'mgnlq_model';\n\n\n\nimport * as Sentence from './sentence';\n\nimport * as Word from './word';\n\nimport * as Algol from './algol';\n\n\n//import * as Match from './match';\n\n\nexport interface ITokenizedString {\n  tokens: string[],\n  categorizedWords: IMatch.ICategorizedStringRanged[][]\n  fusable: boolean[];\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Given a  string, break it down into components,\n * [['A', 'B'], ['A B']]\n *\n * then categorizeWords\n * returning\n *\n * [ [[ { category: 'systemId', word : 'A'},\n *      { category: 'otherthing', word : 'A'}\n *    ],\n *    // result of B\n *    [ { category: 'systemId', word : 'B'},\n *      { category: 'otherthing', word : 'A'}\n *      { category: 'anothertryp', word : 'B'}\n *    ]\n *   ],\n * ]]]\n *\n *\n *\n */\nexport function tokenizeString(sString: string, rules: IMatch.SplitRules,\n  words: { [key: string]: Array<IMatch.ICategorizedString> })\n  : ITokenizedString {\n  var cnt = 0;\n  var fac = 1;\n  var tokens = breakdown.tokenizeString(sString);\n  if (debuglog.enabled) {\n    debuglog(\"here breakdown\" + JSON.stringify(tokens));\n  }\n  //console.log(JSON.stringify(u));\n  words = words || {};\n  perflog('this many known words: ' + Object.keys(words).length);\n  var res = [] as IMatch.ICategorizedStringRanged[][];\n  var cntRec = {};\n  var categorizedSentence = [] as IMatch.ICategorizedStringRanged[][];\n  var hasRecombined = false;\n  tokens.tokens.forEach(function (token, index) {\n    var seenIt = WordMatch.categorizeAWordWithOffsets(token, rules, sString, words, cntRec);\n    /* cannot have this, or need to add all fragment words \"UI2 Integration\"  if(seenIt.length === 0) {\n          return false;\n        }\n    */\n    hasRecombined = hasRecombined || !seenIt.every(res => !res.rule.range);\n    debuglog(debuglog.enabled ? (` categorized ${token}/${index} to ` + JSON.stringify(seenIt))\n     : \"-\");\n    debuglog(debuglog.enabled ? (` categorized ${token}/${index} to ` +\n    seenIt.map( (it,idx) => { return ` ${it.rule.wordType} ${idx} ${it.rule.bitindex}  ${it.rule.matchedString}/${it.rule.category} ` }).join(\"\\n\"))\n     : \"-\");\n    categorizedSentence[index] = seenIt;\n    cnt = cnt + seenIt.length;\n    fac = fac * seenIt.length;\n  });\n  // have seen the plain categorization,\n  debuglog(\" sentences \" + tokens.tokens.length + \" matches \" + cnt + \" fac: \" + fac);\n  if (debuglog.enabled && tokens.tokens.length) {\n    debuglog(\"first match \" + JSON.stringify(tokens, undefined, 2));\n  }\n  debuglog(debuglog.enabled ? ` prior RangeRule ${JSON.stringify(categorizedSentence)} ` : '-');\n  if (hasRecombined) {\n    evaluateRangeRulesToPosition(tokens.tokens, tokens.fusable, categorizedSentence);\n  }\n  debuglog(debuglog.enabled ? ` after RangeRule ${JSON.stringify(categorizedSentence)} ` : '-');\n  perflog(\" sentences \" + tokens.tokens.length + \" / \" + res.length + \" matches \" + cnt + \" fac: \" + fac + \" rec : \" + JSON.stringify(cntRec, undefined, 2));\n  return {\n    fusable: tokens.fusable,\n    tokens: tokens.tokens,\n    categorizedWords: categorizedSentence\n  }\n}\n\nexport function isSameRes(present: IMatch.ICategorizedStringRanged, res : IMatch.ICategorizedStringRanged)  : number {\n  if(!((present.rule.matchedString === res.rule.matchedString)\n    && (present.rule.category === res.rule.category)\n    && (present.span === res.span)\n  && (present.rule.bitindex === res.rule.bitindex))) {\n      return 0;\n  }\n  if(present._ranking < res._ranking) {\n    return -1;\n  }\n  return +1;\n}\n\nexport function mergeIgnoreOrAppend(result : IMatch.ICategorizedStringRanged[], res : IMatch.ICategorizedStringRanged) {\n  var insertindex = -1;\n  var foundNothing = result.every( (present,index) => {\n    var r = isSameRes(present,res);\n    if (r < 0) {\n      //console.log(\"overwriting worse \\n\" + JSON.stringify(res) + '\\n' + JSON.stringify(present)+ '\\n');\n      result[index] = res;\n      return false;\n    } else if(r > 0) {\n      //console.log('skipping present');\n      return false;\n    }\n    return true;\n  });\n  if(foundNothing) {\n    //debulog('pushing');\n    result.push(res);\n  }\n}\n\nexport function evaluateRangeRulesToPosition(tokens: string[], fusable: boolean[], categorizedWords: IMatch.ICategorizedStringRanged[][]) {\n  debuglog(debuglog.enabled ? (\"evaluateRangeRulesToPosition... \" + JSON.stringify(categorizedWords)) : '-');\n  categorizedWords.forEach(function (wordlist, index) {\n    wordlist.forEach(function (word) {\n      if (word.rule.range) {\n        //console.log(` got targetindex for RangeRules evaluation : ${targetIndex} ${index} ${fusable.join(\" \")}`);\n        var targetIndex = breakdown.isCombinableRangeReturnIndex(word.rule.range, fusable, index);\n        //console.log(` got targetindex for RangeRules evaluation : ${targetIndex}`);\n        if (targetIndex >= 0) {\n          var combinedWord = breakdown.combineTokens(word.rule.range, index, tokens);\n          debuglog(debuglog.enabled ? (` test \"${combinedWord}\" against \"${word.rule.range.rule.lowercaseword}\" ${JSON.stringify(word.rule.range.rule)}`) : '-');\n          var res = WordMatch.categorizeWordWithOffsetWithRankCutoffSingle(combinedWord, word.rule.range.rule);\n          debuglog(debuglog.enabled ? (\" got res : \" + JSON.stringify(res)) : '-');\n          if (res) {\n            res.span = word.rule.range.high - word.rule.range.low + 1;\n            categorizedWords[targetIndex] = categorizedWords[targetIndex].slice(0); // avoid invalidation of seenit\n            debuglog(`pushed sth at ${targetIndex}`);\n            mergeIgnoreOrAppend(categorizedWords[targetIndex],res);\n   //         categorizedWords[targetIndex].push(res); // check that this does not invalidate seenit!\n          }\n        }\n      }\n    });\n  });\n  // filter all range rules !\n  categorizedWords.forEach(function (wordlist, index) {\n    categorizedWords[index] = wordlist.filter(word => !word.rule.range);\n  });\n}\n\n\n\n\nconst clone = utils.cloneDeep;\n\n\n\n\nfunction copyVecMembers(u) {\n  var i = 0;\n  for (i = 0; i < u.length; ++i) {\n    u[i] = clone(u[i]);\n  }\n  return u;\n}\n\n\n// we can replicate the tail or the head,\n// we replicate the tail as it is smaller.\n// [a,b,c ]\n\nexport function isSpanVec(vec: Array<any>, index: number) {\n  var effectivelen = vec.reduce((prev, mem) => prev += mem.span ? mem.span : 1, 0);\n  return effectivelen > index;\n}\n\n/**\n * expand an array [[a1,a2], [b1,b2],[c]]\n * into all combinations\n *\n *  if a1 has a span of three, the variations of the lower layer are skipped\n *\n * with the special property\n */\nexport function expandTokenMatchesToSentences(tokens: string[], tokenMatches: Array<Array<any>>): IMatch.IProcessedSentences {\n  var a = [];\n  var wordMatches = [];\n  debuglogV(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\n  tokenMatches.forEach(function (aWordMatches, wordIndex: number) {\n    wordMatches[wordIndex] = [];\n    aWordMatches.forEach(function (oWordVariant, wordVariantIndex: number) {\n      wordMatches[wordIndex][wordVariantIndex] = oWordVariant;\n    });\n  });\n  debuglog(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\n  var result = {\n    errors: [],\n    tokens: tokens,\n    sentences: []\n  } as IMatch.IProcessedSentences;\n  var nvecs = [];\n  var res = [[]];\n  // var nvecs = [];\n  var rvec = [];\n  for (var tokenIndex = 0; tokenIndex < tokenMatches.length; ++tokenIndex) { // wordg index k\n    //vecs is the vector of all so far seen variants up to k length.\n    var nextBase = [];\n    //independent of existence of matches on level k, we retain all vectors which are covered by a span\n    // we skip extending them below\n    for (var u = 0; u < res.length; ++u) {\n      if (isSpanVec(res[u], tokenIndex)) {\n        nextBase.push(res[u]);\n      }\n    }\n    var lenMatches = tokenMatches[tokenIndex].length;\n    if (nextBase.length === 0 && lenMatches === 0) {\n      // the word at index I cannot be understood\n      //if (result.errors.length === 0) {\n      result.errors.push(ERError.makeError_NO_KNOWN_WORD(tokenIndex, tokens));\n      //}\n    }\n    for (var l = 0; l < lenMatches; ++l) { // for each variant present at index k\n      //debuglog(\"vecs now\" + JSON.stringify(vecs));\n      var nvecs = []; //vecs.slice(); // copy the vec[i] base vector;\n      //debuglog(\"vecs copied now\" + JSON.stringify(nvecs));\n      for (var u = 0; u < res.length; ++u) {\n        if (!isSpanVec(res[u], tokenIndex)) {\n          // for each so far constructed result (of length k) in res\n          nvecs.push(res[u].slice()); // make a copy of each vector\n          nvecs[nvecs.length - 1] = copyVecMembers(nvecs[nvecs.length - 1]);\n          // debuglog(\"copied vecs[\"+ u+\"]\" + JSON.stringify(vecs[u]));\n          nvecs[nvecs.length - 1].push(\n            clone(tokenMatches[tokenIndex][l])); // push the lth variant\n          // debuglog(\"now nvecs \" + nvecs.length + \" \" + JSON.stringify(nvecs));\n        }\n      }\n      //   debuglog(\" at     \" + k + \":\" + l + \" nextbase >\" + JSON.stringify(nextBase))\n      //   debuglog(\" append \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nvecs))\n      nextBase = nextBase.concat(nvecs);\n      //   debuglog(\"  result \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nextBase))\n    } //constru\n    //  debuglog(\"now at \" + k + \":\" + l + \" >\" + JSON.stringify(nextBase))\n    res = nextBase;\n  }\n  debuglogV(debuglogV.enabled ? (\"APPENDING TO RES\" + 0 + \":\" + l + \" >\" + JSON.stringify(nextBase)) : '-');\n  result.sentences = res;\n  return result;\n}\n\n// todo: bitindex\nexport function makeAnyWord(token : string) {\n  return { string: token,\n    matchedString: token,\n    category: 'any',\n    rule:\n     { category: 'any',\n       type: 0,\n       word: token,\n       lowercaseword: token.toLowerCase(),\n       matchedString: token,\n       exactOnly: true,\n       bitindex: 4096,\n       bitSentenceAnd: 4095,\n       wordType: 'A', // IMatch.WORDTYPE.ANY,\n       _ranking: 0.9 },\n    _ranking: 0.9\n  };\n}\n\nexport function isSuccessorOperator(res : any, tokenIndex : number) : boolean {\n  if(tokenIndex === 0) {\n    return false;\n  }\n  if(res[res.length-1].rule.wordType === 'O') {\n    //debuglog(` assumuning op at ${tokenIndex} ` + JSON.stringify(res, undefined, 2));\n    return true;\n  }\n  return false;\n}\n/**\n * expand an array [[a1,a2], [b1,b2],[c]]\n * into all combinations\n *\n *  if a1 has a span of three, the variations of the lower layer are skipped\n *\n * with the special property\n */\nexport function expandTokenMatchesToSentences2(tokens: string[], tokenMatches: Array<Array<any>>): IMatch.IProcessedSentences {\n  var a = [];\n  var wordMatches = [];\n  debuglogV(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\n  tokenMatches.forEach(function (aWordMatches, wordIndex: number) {\n    wordMatches[wordIndex] = [];\n    aWordMatches.forEach(function (oWordVariant, wordVariantIndex: number) {\n      wordMatches[wordIndex][wordVariantIndex] = oWordVariant;\n    });\n  });\n  debuglog(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\n  var result = {\n    errors: [],\n    tokens: tokens,\n    sentences: []\n  } as IMatch.IProcessedSentences;\n  var nvecs = [];\n  var res = [[]];\n  // var nvecs = [];\n  var rvec = [];\n  for (var tokenIndex = 0; tokenIndex < tokenMatches.length; ++tokenIndex) { // wordg index k\n    //vecs is the vector of all so far seen variants up to tokenIndex length.\n    var nextBase = [];\n    // independent of existence of matches on level k, we retain all vectors which are covered by a span\n    // we skip extending them below\n    for (var u = 0; u < res.length; ++u) {\n      if (isSpanVec(res[u], tokenIndex)) {\n        nextBase.push(res[u]);\n      } else if( isSuccessorOperator(res[u],tokenIndex)) {\n        res[u].push(makeAnyWord(tokens[tokenIndex]));\n        nextBase.push(res[u]);\n      }\n    }\n    // independent of existence of matches on level tokenIndex, we extend all vectors which\n    // are a successor of a binary extending op ( like \"starting with\", \"containing\" with the next token)\n    /*   for(var resIndex = 0; resIndex < res.length; ++resIndex) {\n      if (isSuccessorOperator(res[resIndex], tokenIndex)) {\n        res[resIndex].push(makeAnyWord(tokens[tokenIndex]));\n        nextBase.push(res[resIndex]);\n      }\n    }\n    */\n    var lenMatches = tokenMatches[tokenIndex].length;\n    if (nextBase.length === 0 && lenMatches === 0) {\n      // the word at index I cannot be understood\n      //if (result.errors.length === 0) {\n      result.errors.push(ERError.makeError_NO_KNOWN_WORD(tokenIndex, tokens));\n      //}\n    }\n    for (var l = 0; l < lenMatches; ++l) { // for each variant present at index k\n      //debuglog(\"vecs now\" + JSON.stringify(vecs));\n      var nvecs = []; //vecs.slice(); // copy the vec[i] base vector;\n      //debuglog(\"vecs copied now\" + JSON.stringify(nvecs));\n      for (var u = 0; u < res.length; ++u) {\n        if (!isSpanVec(res[u], tokenIndex) && !isSuccessorOperator(res[u],tokenIndex)) {\n          // for each so far constructed result (of length k) in res\n          nvecs.push(res[u].slice()); // make a copy of each vector\n          nvecs[nvecs.length - 1] = copyVecMembers(nvecs[nvecs.length - 1]);\n          // debuglog(\"copied vecs[\"+ u+\"]\" + JSON.stringify(vecs[u]));\n          nvecs[nvecs.length - 1].push(\n            clone(tokenMatches[tokenIndex][l])); // push the lth variant\n          // debuglog(\"now nvecs \" + nvecs.length + \" \" + JSON.stringify(nvecs));\n        }\n      }\n      //   debuglog(\" at     \" + k + \":\" + l + \" nextbase >\" + JSON.stringify(nextBase))\n      //   debuglog(\" append \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nvecs))\n      nextBase = nextBase.concat(nvecs);\n      //   debuglog(\"  result \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nextBase))\n    } //constru\n    //  debuglog(\"now at \" + k + \":\" + l + \" >\" + JSON.stringify(nextBase))\n    res = nextBase;\n  }\n  debuglogV(debuglogV.enabled ? (\"APPENDING TO RES\" + 0 + \":\" + l + \" >\" + JSON.stringify(nextBase)) : '-');\n  res = res.filter( (sentence,index) => {\n    var full = 0xFFFFFFFF;\n    //console.log(`sentence  ${index}  \\n`)\n    return sentence.every( (word,index2) => { full = full & word.rule.bitSentenceAnd;\n      //console.log(` word  ${index2} ${full} \"${word.matchedString}\" ${word.rule.bitSentenceAnd}  ${tokens[index2]} \\n`);\n      return full !== 0 } )\n  });\n  result.sentences = res;\n  return result;\n}\n\n\n\nexport function processString(query: string, rules: IFModel.SplitRules,\n words: { [key: string]: Array<IMatch.ICategorizedString> }\n):  IMatch.IProcessedSentences {\n  words = words || {};\n  if(!process.env.ABOT_NO_TEST1) {\n    return processString2(query, rules, words);\n  }\n  var tokenStruct = tokenizeString(query, rules, words);\n  evaluateRangeRulesToPosition(tokenStruct.tokens, tokenStruct.fusable,\n    tokenStruct.categorizedWords);\n  if (debuglog.enabled) {\n    debuglog(\"After matched \" + JSON.stringify(tokenStruct.categorizedWords));\n  }\n  var aSentences = expandTokenMatchesToSentences(tokenStruct.tokens, tokenStruct.categorizedWords);\n  if (debuglog.enabled) {\n    debuglog(\"after expand\" + aSentences.sentences.map(function (oSentence) {\n    return Sentence.rankingProduct(oSentence) + \":\" + Sentence.dumpNice(oSentence); //JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  }\n  aSentences.sentences = WordMatch.reinForce(aSentences.sentences);\n  if (debuglog.enabled) {\n    debuglog(\"after reinforce\" + aSentences.sentences.map(function (oSentence) {\n      return Sentence.rankingProduct(oSentence) + \":\" + JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  }\n  return aSentences;\n}\n\n/**\n * Return true if the identical word is interpreted\n * (within the same domain and the same wordtype)\n * as a differnent  (e.g. element numb is one interpreted as 'CAT' element name, once as CAT 'element number' in\n * same domain IUPAC elements )\n * @param sentence\n */\nexport function isDistinctInterpretationForSame(sentence : IMatch.ISentence) : boolean {\n  var mp = {} as {[key : string] : IMatch.IWord};\n  var res = sentence.every((word, index) => {\n    var seen = mp[word.string];\n    if(!seen) {\n      mp[word.string] = word;\n      return true;\n    }\n    if(!seen.rule || !word.rule) {\n      return true;\n    }\n    if(seen.rule.bitindex === word.rule.bitindex\n      && seen.rule.matchedString !== word.rule.matchedString ){\n      //  console.log(\"skipping this\" + JSON.stringify(sentence,undefined,2));\n        return false;\n    }\n    return true;\n  });\n  return res;\n}\n\nexport function filterNonSameInterpretations(aSentences :  IMatch.IProcessedSentences ) : IMatch.IProcessedSentences {\n  var discardIndex = [] as Array<number>;\n  var res = (Object as any).assign( {}, aSentences );\n  res.sentences = aSentences.sentences.filter((sentence,index) => {\n    if(!isDistinctInterpretationForSame(sentence)) {\n      discardIndex.push(index);\n      return false;\n    }\n    return true;\n  });\n  if(discardIndex.length) {\n    res.errors = aSentences.errors.filter( (error,index) => {\n      if(discardIndex.indexOf(index) >= 0) {\n        return false;\n      }\n      return true;\n    });\n  }\n  return res;\n}\n\nexport function processString2(query: string, rules: IFModel.SplitRules,\n words: { [key: string]: Array<IMatch.ICategorizedString> }\n):  IMatch.IProcessedSentences {\n  words = words || {};\n  var tokenStruct = tokenizeString(query, rules, words);\n  evaluateRangeRulesToPosition(tokenStruct.tokens, tokenStruct.fusable,\n    tokenStruct.categorizedWords);\n  if (debuglog.enabled) {\n    debuglog(\"After matched \" + JSON.stringify(tokenStruct.categorizedWords));\n  }\n  var aSentences = expandTokenMatchesToSentences2(tokenStruct.tokens, tokenStruct.categorizedWords);\n  if (debuglog.enabled) {\n    debuglog(\"after expand\" + aSentences.sentences.map(function (oSentence) {\n    return Sentence.rankingProduct(oSentence) + \":\" + Sentence.dumpNice(oSentence); //JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  }\n\n  var aSentences = filterNonSameInterpretations(aSentences);\n\n\n  aSentences.sentences = WordMatch.reinForce(aSentences.sentences);\n  if (debuglog.enabled) {\n    debuglog(\"after reinforce\" + aSentences.sentences.map(function (oSentence) {\n      return Sentence.rankingProduct(oSentence) + \":\" + JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  }\n  return aSentences;\n}\n\n\nexport function simplifySentence(res) {\n  return res.map(function (r) {\n    return r.map(word => { return word.string + '=>' + word.matchedString + '/' + word.category + (word.span ? '/' + word.span : '') })\n  });\n}\n"],"sourceRoot":"ABC"}