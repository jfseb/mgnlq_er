{"version":3,"sources":["../src/match/erbase.ts"],"names":[],"mappings":"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","file":"match/erbase.js","sourcesContent":["/**\n *\n * @module jfseb.erbase\n * @file erbase\n * @copyright (c) 2016 Gerd Forstmann\n *\n * Basic domain based entity recognition\n *\n */\n\n\nimport * as WordMatch from './inputFilter';\nimport * as CharSequence from './charsequence';\n\nimport * as debug from 'debugf';\n\n\n\nvar debuglog = debug('erbase');\nvar debuglogV = debug('erVbase');\nvar perflog = debug('perf');\n\nimport { BreakDown as breakdown}  from 'mgnlq_model';\nimport * as ERError from './ererror';\n\nconst AnyObject = <any>Object;\n\nexport function mockDebug(o) {\n  debuglog = o;\n  debuglogV = o;\n  perflog = o;\n}\n\n\nimport * as utils from 'abot_utils';\n\nimport * as IFErBase from './iferbase';\nimport { IFModel  as IMatch}  from 'mgnlq_model';\nimport { IFModel  as IFModel}  from 'mgnlq_model';\n\n\n\nimport * as Sentence from './sentence';\n\nimport * as Word from './word';\n\nimport * as Algol from './algol';\nimport { AssertionError } from 'assert';\n\n\n//import * as Match from './match';\n\n\nexport interface ITokenizedString {\n  tokens: string[],\n  categorizedWords: IMatch.ICategorizedStringRanged[][]\n  fusable: boolean[];\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Given a  string, break it down into components,\n * [['A', 'B'], ['A B']]\n *\n * then categorizeWords\n * returning\n *\n * [ [[ { category: 'systemId', word : 'A'},\n *      { category: 'otherthing', word : 'A'}\n *    ],\n *    // result of B\n *    [ { category: 'systemId', word : 'B'},\n *      { category: 'otherthing', word : 'A'}\n *      { category: 'anothertryp', word : 'B'}\n *    ]\n *   ],\n * ]]]\n *\n *\n *\n */\nexport function tokenizeString(sString: string, rules: IMatch.SplitRules,\n  words: { [key: string]: Array<IMatch.ICategorizedString> })\n  : ITokenizedString {\n  var cnt = 0;\n  var fac = 1;\n  var tokens = breakdown.tokenizeString(sString);\n  if (debuglog.enabled) {\n    debuglog(\"here breakdown\" + JSON.stringify(tokens));\n  }\n  //console.log(JSON.stringify(u));\n  words = words || {};\n  perflog('this many known words: ' + Object.keys(words).length);\n  var res = [] as IMatch.ICategorizedStringRanged[][];\n  var cntRec = {};\n  var categorizedSentence = [] as IMatch.ICategorizedStringRanged[][];\n  var hasRecombined = false;\n  tokens.tokens.forEach(function (token, index) {\n    var seenIt = WordMatch.categorizeAWordWithOffsets(token, rules, sString, words, cntRec);\n    /* cannot have this, or need to add all fragment words \"UI2 Integration\"  if(seenIt.length === 0) {\n          return false;\n        }\n    */\n    hasRecombined = hasRecombined || !seenIt.every(res => !res.rule.range);\n    debuglogV(debuglogV.enabled ? (` categorized ${token}/${index} to ` + JSON.stringify(seenIt))\n     : \"-\");\n    debuglog(debuglog.enabled ? (` categorized ${token}/${index} to ` +\n    seenIt.map( (it,idx) => { return ` ${idx}  ${it.rule.matchedString}/${it.rule.category}  ${it.rule.wordType}${it.rule.bitindex} ` }).join(\"\\n\"))\n     : \"-\");\n    categorizedSentence[index] = seenIt;\n    cnt = cnt + seenIt.length;\n    fac = fac * seenIt.length;\n  });\n  // have seen the plain categorization,\n  debuglog(\" sentences \" + tokens.tokens.length + \" matches \" + cnt + \" fac: \" + fac);\n  if (debuglog.enabled && tokens.tokens.length) {\n    debuglog(\"first match \" + JSON.stringify(tokens, undefined, 2));\n  }\n  debuglog(debuglog.enabled ? ` prior RangeRule ${JSON.stringify(categorizedSentence)} ` : '-');\n  if (hasRecombined) {\n    evaluateRangeRulesToPosition(tokens.tokens, tokens.fusable, categorizedSentence);\n  }\n  debuglog(debuglog.enabled ? ` after RangeRule ${JSON.stringify(categorizedSentence)} ` : '-');\n  perflog(\" sentences \" + tokens.tokens.length + \" / \" + res.length + \" matches \" + cnt + \" fac: \" + fac + \" rec : \" + JSON.stringify(cntRec, undefined, 2));\n  return {\n    fusable: tokens.fusable,\n    tokens: tokens.tokens,\n    categorizedWords: categorizedSentence\n  }\n}\n\nexport function isSameRes(present: IMatch.ICategorizedStringRanged, res : IMatch.ICategorizedStringRanged)  : number {\n  if(!((present.rule.matchedString === res.rule.matchedString)\n    && (present.rule.category === res.rule.category)\n    && (present.span === res.span)\n  && (present.rule.bitindex === res.rule.bitindex))) {\n      return 0;\n  }\n  if(present._ranking < res._ranking) {\n    return -1;\n  }\n  return +1;\n}\n\nexport function mergeIgnoreOrAppend(result : IMatch.ICategorizedStringRanged[], res : IMatch.ICategorizedStringRanged) {\n  var insertindex = -1;\n  var foundNothing = result.every( (present,index) => {\n    var r = isSameRes(present,res);\n    if (r < 0) {\n      //console.log(\"overwriting worse \\n\" + JSON.stringify(res) + '\\n' + JSON.stringify(present)+ '\\n');\n      result[index] = res;\n      return false;\n    } else if(r > 0) {\n      //console.log('skipping present');\n      return false;\n    }\n    return true;\n  });\n  if(foundNothing) {\n    //debulog('pushing');\n    result.push(res);\n  }\n}\n\nexport function evaluateRangeRulesToPosition(tokens: string[], fusable: boolean[], categorizedWords: IMatch.ICategorizedStringRanged[][]) {\n  debuglog(debuglog.enabled ? (\"evaluateRangeRulesToPosition... \" + JSON.stringify(categorizedWords)) : '-');\n  categorizedWords.forEach(function (wordlist, index) {\n    wordlist.forEach(function (word) {\n      if (word.rule.range) {\n        //console.log(` got targetindex for RangeRules evaluation : ${targetIndex} ${index} ${fusable.join(\" \")}`);\n        var targetIndex = breakdown.isCombinableRangeReturnIndex(word.rule.range, fusable, index);\n        //console.log(` got targetindex for RangeRules evaluation : ${targetIndex}`);\n        if (targetIndex >= 0) {\n          var combinedWord = breakdown.combineTokens(word.rule.range, index, tokens);\n          debuglog(debuglog.enabled ? (` test \"${combinedWord}\" against \"${word.rule.range.rule.lowercaseword}\" ${JSON.stringify(word.rule.range.rule)}`) : '-');\n          var res = WordMatch.categorizeWordWithOffsetWithRankCutoffSingle(combinedWord, word.rule.range.rule);\n          debuglog(debuglog.enabled ? (\" got res : \" + JSON.stringify(res)) : '-');\n          if (res) {\n            res.span = word.rule.range.high - word.rule.range.low + 1;\n            categorizedWords[targetIndex] = categorizedWords[targetIndex].slice(0); // avoid invalidation of seenit\n            debuglog(`pushed sth at ${targetIndex}`);\n            mergeIgnoreOrAppend(categorizedWords[targetIndex],res);\n   //         categorizedWords[targetIndex].push(res); // check that this does not invalidate seenit!\n          }\n        }\n      }\n    });\n  });\n  // filter all range rules !\n  categorizedWords.forEach(function (wordlist, index) {\n    categorizedWords[index] = wordlist.filter(word => !word.rule.range);\n  });\n}\n\n\n\n\nconst clone = utils.cloneDeep;\n\n\n\n\nfunction copyVecMembers(u) {\n  var i = 0;\n  for (i = 0; i < u.length; ++i) {\n    u[i] = clone(u[i]);\n  }\n  return u;\n}\n\n\n// we can replicate the tail or the head,\n// we replicate the tail as it is smaller.\n// [a,b,c ]\n\nexport function isSpanVec(vec: Array<any>, index: number) {\n  var effectivelen = vec.reduce((prev, mem) => prev += mem.span ? mem.span : 1, 0);\n  return effectivelen > index;\n}\n\n/**\n * expand an array [[a1,a2], [b1,b2],[c]]\n * into all combinations\n *\n *  if a1 has a span of three, the variations of the lower layer are skipped\n *\n * with the special property\n */\nexport function expandTokenMatchesToSentences(tokens: string[], tokenMatches: Array<Array<any>>): IMatch.IProcessedSentences {\n  var a = [];\n  var wordMatches = [];\n  debuglogV(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\n  tokenMatches.forEach(function (aWordMatches, wordIndex: number) {\n    wordMatches[wordIndex] = [];\n    aWordMatches.forEach(function (oWordVariant, wordVariantIndex: number) {\n      wordMatches[wordIndex][wordVariantIndex] = oWordVariant;\n    });\n  });\n  debuglog(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\n  var result = {\n    errors: [],\n    tokens: tokens,\n    sentences: []\n  } as IMatch.IProcessedSentences;\n  var nvecs = [];\n  var res = [[]];\n  // var nvecs = [];\n  var rvec = [];\n  for (var tokenIndex = 0; tokenIndex < tokenMatches.length; ++tokenIndex) { // wordg index k\n    //vecs is the vector of all so far seen variants up to k length.\n    var nextBase = [];\n    //independent of existence of matches on level k, we retain all vectors which are covered by a span\n    // we skip extending them below\n    for (var u = 0; u < res.length; ++u) {\n      if (isSpanVec(res[u], tokenIndex)) {\n        nextBase.push(res[u]);\n      }\n    }\n    var lenMatches = tokenMatches[tokenIndex].length;\n    if (nextBase.length === 0 && lenMatches === 0) {\n      // the word at index I cannot be understood\n      //if (result.errors.length === 0) {\n      result.errors.push(ERError.makeError_NO_KNOWN_WORD(tokenIndex, tokens));\n      //}\n    }\n    for (var l = 0; l < lenMatches; ++l) { // for each variant present at index k\n      //debuglog(\"vecs now\" + JSON.stringify(vecs));\n      var nvecs = []; //vecs.slice(); // copy the vec[i] base vector;\n      //debuglog(\"vecs copied now\" + JSON.stringify(nvecs));\n      for (var u = 0; u < res.length; ++u) {\n        if (!isSpanVec(res[u], tokenIndex)) {\n          // for each so far constructed result (of length k) in res\n          nvecs.push(res[u].slice()); // make a copy of each vector\n          nvecs[nvecs.length - 1] = copyVecMembers(nvecs[nvecs.length - 1]);\n          // debuglog(\"copied vecs[\"+ u+\"]\" + JSON.stringify(vecs[u]));\n          nvecs[nvecs.length - 1].push(\n            clone(tokenMatches[tokenIndex][l])); // push the lth variant\n          // debuglog(\"now nvecs \" + nvecs.length + \" \" + JSON.stringify(nvecs));\n        }\n      }\n      //   debuglog(\" at     \" + k + \":\" + l + \" nextbase >\" + JSON.stringify(nextBase))\n      //   debuglog(\" append \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nvecs))\n      nextBase = nextBase.concat(nvecs);\n      //   debuglog(\"  result \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nextBase))\n    } //constru\n    //  debuglog(\"now at \" + k + \":\" + l + \" >\" + JSON.stringify(nextBase))\n    res = nextBase;\n  }\n  debuglogV(debuglogV.enabled ? (\"APPENDING TO RES\" + 0 + \":\" + l + \" >\" + JSON.stringify(nextBase)) : '-');\n  result.sentences = res;\n  return result;\n}\n\n// todo: bitindex\nexport function makeAnyWord(token : string) {\n  return { string: token,\n    matchedString: token,\n    category: 'any',\n    rule:\n     { category: 'any',\n       type: 0,\n       word: token,\n       lowercaseword: token.toLowerCase(),\n       matchedString: token,\n       exactOnly: true,\n       bitindex: 4096,\n       bitSentenceAnd: 4095,\n       wordType: 'A', // IMatch.WORDTYPE.ANY,\n       _ranking: 0.9 },\n    _ranking: 0.9\n  };\n}\n\nexport function isSuccessorOperator(res : any, tokenIndex : number) : boolean {\n  if(tokenIndex === 0) {\n    return false;\n  }\n  if(res[res.length-1].rule.wordType === 'O') {\n    //debuglog(` assumuning op at ${tokenIndex} ` + JSON.stringify(res, undefined, 2));\n    return true;\n  }\n  return false;\n}\n/**\n * expand an array [[a1,a2], [b1,b2],[c]]\n * into all combinations\n *\n *  if a1 has a span of three, the variations of the lower layer are skipped\n *\n * with the special property\n */\nexport function expandTokenMatchesToSentences2(tokens: string[], tokenMatches: Array<Array<any>>): IMatch.IProcessedSentences {\n  var a = [];\n  var wordMatches = [];\n  debuglogV(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\n  tokenMatches.forEach(function (aWordMatches, wordIndex: number) {\n    wordMatches[wordIndex] = [];\n    aWordMatches.forEach(function (oWordVariant, wordVariantIndex: number) {\n      wordMatches[wordIndex][wordVariantIndex] = oWordVariant;\n    });\n  });\n  debuglog(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\n  var result = {\n    errors: [],\n    tokens: tokens,\n    sentences: []\n  } as IMatch.IProcessedSentences;\n  var nvecs = [];\n  var res = [[]];\n  // var nvecs = [];\n  var rvec = [];\n  for (var tokenIndex = 0; tokenIndex < tokenMatches.length; ++tokenIndex) { // wordg index k\n    //vecs is the vector of all so far seen variants up to tokenIndex length.\n    var nextBase = [];\n    // independent of existence of matches on level k, we retain all vectors which are covered by a span\n    // we skip extending them below\n    for (var u = 0; u < res.length; ++u) {\n      if (isSpanVec(res[u], tokenIndex)) {\n        nextBase.push(res[u]);\n      } else if( isSuccessorOperator(res[u],tokenIndex)) {\n        res[u].push(makeAnyWord(tokens[tokenIndex]));\n        nextBase.push(res[u]);\n      }\n    }\n    // independent of existence of matches on level tokenIndex, we extend all vectors which\n    // are a successor of a binary extending op ( like \"starting with\", \"containing\" with the next token)\n    /*   for(var resIndex = 0; resIndex < res.length; ++resIndex) {\n      if (isSuccessorOperator(res[resIndex], tokenIndex)) {\n        res[resIndex].push(makeAnyWord(tokens[tokenIndex]));\n        nextBase.push(res[resIndex]);\n      }\n    }\n    */\n    var lenMatches = tokenMatches[tokenIndex].length;\n    if (nextBase.length === 0 && lenMatches === 0) {\n      // the word at index I cannot be understood\n      //if (result.errors.length === 0) {\n      result.errors.push(ERError.makeError_NO_KNOWN_WORD(tokenIndex, tokens));\n      //}\n    }\n    for (var l = 0; l < lenMatches; ++l) { // for each variant present at index k\n      //debuglog(\"vecs now\" + JSON.stringify(vecs));\n      var nvecs = []; //vecs.slice(); // copy the vec[i] base vector;\n      //debuglog(\"vecs copied now\" + JSON.stringify(nvecs));\n      for (var u = 0; u < res.length; ++u) {\n        if (!isSpanVec(res[u], tokenIndex) && !isSuccessorOperator(res[u],tokenIndex)) {\n          // for each so far constructed result (of length k) in res\n          nvecs.push(res[u].slice()); // make a copy of each vector\n          nvecs[nvecs.length - 1] = copyVecMembers(nvecs[nvecs.length - 1]);\n          // debuglog(\"copied vecs[\"+ u+\"]\" + JSON.stringify(vecs[u]));\n          nvecs[nvecs.length - 1].push(\n            clone(tokenMatches[tokenIndex][l])); // push the lth variant\n          // debuglog(\"now nvecs \" + nvecs.length + \" \" + JSON.stringify(nvecs));\n        }\n      }\n      //   debuglog(\" at     \" + k + \":\" + l + \" nextbase >\" + JSON.stringify(nextBase))\n      //   debuglog(\" append \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nvecs))\n      nextBase = nextBase.concat(nvecs);\n      //   debuglog(\"  result \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nextBase))\n    } //constru\n    //  debuglog(\"now at \" + k + \":\" + l + \" >\" + JSON.stringify(nextBase))\n    res = nextBase;\n  }\n  debuglogV(debuglogV.enabled ? (\"APPENDING TO RES\" + 0 + \":\" + l + \" >\" + JSON.stringify(nextBase)) : '-');\n  res = res.filter( (sentence,index) => {\n    var full = 0xFFFFFFFF;\n    //console.log(`sentence  ${index}  \\n`)\n    return sentence.every( (word,index2) => { full = full & word.rule.bitSentenceAnd;\n      //console.log(` word  ${index2} ${full} \"${word.matchedString}\" ${word.rule.bitSentenceAnd}  ${tokens[index2]} \\n`);\n      return full !== 0 } )\n  });\n  result.sentences = res;\n  return result;\n}\n\n\n\nexport function processString(query: string, rules: IFModel.SplitRules,\n words: { [key: string]: Array<IMatch.ICategorizedString> }\n):  IMatch.IProcessedSentences {\n  words = words || {};\n  //if(!process.env.ABOT_NO_TEST1) {\n  return processString2(query, rules, words);\n}\n  /*\n  var tokenStruct = tokenizeString(query, rules, words);\n  evaluateRangeRulesToPosition(tokenStruct.tokens, tokenStruct.fusable,\n    tokenStruct.categorizedWords);\n  if (debuglog.enabled) {\n    debuglog(\"After matched \" + JSON.stringify(tokenStruct.categorizedWords));\n  }\n  var aSentences = expandTokenMatchesToSentences(tokenStruct.tokens, tokenStruct.categorizedWords);\n  if (debuglog.enabled) {\n    debuglog(\"after expand\" + aSentences.sentences.map(function (oSentence) {\n    return Sentence.rankingProduct(oSentence) + \":\" + Sentence.dumpNice(oSentence); //JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  }\n  aSentences.sentences = WordMatch.reinForce(aSentences.sentences);\n  if (debuglog.enabled) {\n    debuglog(\"after reinforce\" + aSentences.sentences.map(function (oSentence) {\n      return Sentence.rankingProduct(oSentence) + \":\" + JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  }\n  return aSentences;\n  */\n\n\nexport function findCloseIdenticals( mp :  {[key : string] : IMatch.IWord}, word : IMatch.IWord ) : Array<IMatch.IWord>\n{\n  var res = [] as Array<IMatch.IWord>;\n  for( var key in mp )\n  {\n    if ( key == word.string )\n    {\n      res.push( mp[ key ]);\n    }\n    else if ( CharSequence.CharSequence.isSameOrPluralOrVeryClose( key, word.string ) )\n    {\n      res.push( mp[key] );\n    }\n  }\n  return res;\n}\n\n/* Return true if the identical *source word* is interpreted\n* (within the same domain and the same wordtype)\n* as a differnent  (e.g. element numb is one interpreted as 'CAT' element name, once as CAT 'element number' in\n*\n* example\n* [ 'element names=>element number/category/2 F16',         <<< (1)\n*    'element number=>element number/category/2 F16',\n*    'element weight=>atomic weight/category/2 F16',\n*    'element name=>element name/category/2 F16',           <<< (2)\n*    'with=>with/filler I256',\n*    'element name=>element name/category/2 F16',           <<< (3)\n*   'starting with=>starting with/operator/2 O256',\n*    'ABC=>ABC/any A4096' ],\n*\n* same domain IUPAC elements)\n*\n*  (1) differs to (2),(3) although the base words are very similar element names, element name, element name respectively\n*\n* - exact match\n* - stemming by removing/appending traling s\n* - closeness\n*\n* @param sentence\n*/\nexport function isDistinctInterpretationForSame(sentence : IMatch.ISentence) : boolean {\n  var mp = {} as {[key : string] : IMatch.IWord};\n  var res = sentence.every((word, index) => {\n    var seens = findCloseIdenticals( mp, word );\n    debuglog(\" investigating seens for \" + word.string + \" \" + JSON.stringify(seens, undefined, 2));\n    for( var seen of seens)\n    {\n      //var seen = mp[word.string];\n      /*if(!seen) {\n        mp[word.string] = word;\n        return true;\n      }*/\n      if(!seen.rule || !word.rule) {\n        //return true;\n      }\n      else if(seen.rule.bitindex === word.rule.bitindex\n        && seen.rule.matchedString !== word.rule.matchedString ){\n          debuglog(\"skipping this\" + JSON.stringify(sentence,undefined,2));\n          return false;\n      }\n    }\n    if(!mp[word.string])\n    {\n      mp[word.string] = word;\n      return true;\n    }\n    return true;\n });\n return res;\n}\n\nexport function isSameCategoryAndHigherMatch(sentence : IMatch.ISentence,  idxmap : { [akey : number] : Array<IMatch.IWord> }) : boolean {\n  var idxmapother = {} as { [akey : number] : Array<IMatch.IWord> };\n  var cnt = 0;\n  var prodo =1.0;\n  var prod = 1.0;\n  Object.keys( idxmap ).forEach( (idxkey) => {\n    var wrd = idxmap[idxkey];\n    var idx = parseInt( idxkey );\n    if ( sentence.length > idx )\n    {\n      var wrdo = sentence[idx];\n      if( wrdo.string === wrd.string\n        && wrdo.rule.bitindex === wrd.rule.bitindex\n        && wrdo.rule.wordType === wrd.rule.wordType\n        && wrdo.rule.category === wrd.rule.category )\n      {\n        ++cnt;\n        prodo = prodo * wrdo._ranking;\n        prod = prod * wrd._ranking;\n      }\n    }\n  });\n  if ( cnt === Object.keys( idxmap ).length && prodo > prod )\n  {\n    return true;\n  }\n  return false;\n}\n\n\n/* Return true if the identical *target word* is expressed by different source words\n* (within the same domain and the same wordtype)\n*\n* this is problematic with aliases mapped onto the same target, (eg. where -> with, with -> where )\n* so perhaps only for categories and facts?\n*\n* example <pre>\n* [ 'element names=>element number/category/2 C8',         <<< (1a)\n*    'element number=>element number/category/2 C8',       <<< (2)\n*    'element weight=>atomic weight/category/2 C8',\n*    'element name=>element number/category/2 C8',           <<< (1b)\n*    'with=>with/filler I256',\n*    'element name=>element number/category/2 C8',           <<< (1c)\n*    'starting with=>starting with/operator/2 O256',\n*    'ABC=>ABC/any A4096' ],\n*\n* same domain IUPAC elements)\n*\n*  (1abc) differs from (2),\n*  and there is a much better interpretation around\n* </pre>\n* - exact match\n* - stemming by removing/appending traling s\n* - closeness\n*\n* @param sentence\n*/\nexport function isNonOptimalDistinctSourceForSame(sentence : IMatch.ISentence, sentences : Array<IMatch.ISentence>) : boolean {\n  var mp = {} as {[key : string] :  { [key : number] : Array<IMatch.IWord> } };\n  // calculate conflicts :    [taget_word -> ]\n  var res = sentence.every((word) => {\n    if ( word.category === Word.Category.CAT_CATEGORY\n      && (  word.rule.wordType === IMatch.WORDTYPE.FACT\n         || word.rule.wordType === IMatch.WORDTYPE.CATEGORY ))\n    {\n      if (!mp[word.rule.matchedString ])\n        mp[word.rule.matchedString] = {} as { [key : number] : Array<IMatch.IWord> };\n      if( !mp[word.rule.matchedString][word.rule.bitindex])\n        mp[word.rule.matchedString][word.rule.bitindex] = [] as  Array<IMatch.IWord>;\n      var arr = mp[word.rule.matchedString][word.rule.bitindex];\n      if( arr.length == 0 )\n      {\n        arr.push(word);\n      }\n      if ( !arr.every( (presentword) => {\n        return CharSequence.CharSequence.isSameOrPluralOrVeryClose( word.string, presentword.string );\n      }))\n      {\n        arr.push( word );\n      }\n    }\n    // retain only entries with more than one member in the list\n    var mpduplicates = {} as {[key : string] :  { [key : number] : Array<IMatch.IWord> } };\n    Object.keys( mp ).forEach( (key) => {\n      var entry = mp[key];\n      Object.keys( entry ).forEach( (keybitindex) => {\n        if ( entry[keybitindex].length > 1)\n        {\n          if (!mpduplicates[key])\n            mpduplicates[key] = {} as { [key : number] : Array<IMatch.IWord> };\n          mpduplicates[key][keybitindex] = entry[keybitindex];\n        }\n      });\n    });\n    return Object.keys( mpduplicates ).every( (key) =>  {\n      return Object.keys( mpduplicates[ key ] ).every( ( bi ) => {\n        var lst = mpduplicates[key][bi];\n        var idxmap = {} as { [akey : number] : Array<IMatch.IWord> };\n        /* ok, do some work ..  */\n        /* for every duplicate we collect an index  idx -> word */\n        for( var alst of lst )\n        {\n          var idx = sentence.indexOf( alst );\n          if ( idx < 0 )\n            throw new Error(\"word must be found in sentence \");\n          idxmap[ idx ] = alst;\n        }\n        /* then we run through all the sentences identifying *identical source words pairs,\n           if we find a  a) distinct sentence with\n                      b) same categories F16/F16\n                  and c) *higher matches* for both , then we discard *this* sentence\n                  */\n        return sentences.every( (othersentence) => {\n          if( othersentence === sentence )\n            return true;\n          if ( isSameCategoryAndHigherMatch( othersentence, idxmap) )\n          {\n            debuglog(\" removing sentence with due to higher match \" +  Sentence.simplifyStringsWithBitIndex(sentence)\n            + \" as \" + Sentence.simplifyStringsWithBitIndex( othersentence ) + \" appears better \");\n            return false;\n          }\n          return true;\n        });\n      })\n    });\n  });\n  debuglog(\" here res \" + !res + \" \" +  Sentence.simplifyStringsWithBitIndex(sentence) );\n  return !res;\n}\n\n\n/*\n * Return true if the identical source word is interpreted\n * (within the same domain and the same wordtype)\n * as a differnent  (e.g. element numb is one interpreted as 'CAT' element name, once as CAT 'element number' in\n * same domain IUPAC elements)\n *\n * - exact match\n * - stemming by removing/appending traling s\n * - closeness\n *\n * @param sentence\n */\nexport function isDistinctInterpretationForSameOLD(sentence : IMatch.ISentence) : boolean {\n  var mp = {} as {[key : string] : IMatch.IWord};\n  var res = sentence.every((word, index) => {\n    var seen = mp[word.string];\n    if(!seen)\n    { // exact match\n      /*if( word.string.length > 3 && word.string.charAt(word.string.length - 1).toLowerCase() == 's')\n      {\n\n      }\n      */\n    }\n    if(!seen) {\n      mp[word.string] = word;\n      return true;\n    }\n    if(!seen.rule || !word.rule) {\n      return true;\n    }\n    if(seen.rule.bitindex === word.rule.bitindex\n      && seen.rule.matchedString !== word.rule.matchedString ){\n      //  console.log(\"skipping this\" + JSON.stringify(sentence,undefined,2));\n        return false;\n    }\n    return true;\n  });\n  return res;\n}\n\nexport function filterNonSameInterpretations(aSentences :  IMatch.IProcessedSentences ) : IMatch.IProcessedSentences {\n  var discardIndex = [] as Array<number>;\n  var res = (Object as any).assign( {}, aSentences );\n  res.sentences = aSentences.sentences.filter((sentence,index) => {\n    if(!isDistinctInterpretationForSame(sentence)) {\n      discardIndex.push(index);\n      return false;\n    }\n    return true;\n  });\n  if(discardIndex.length) {\n    res.errors = aSentences.errors.filter( (error,index) => {\n      if(discardIndex.indexOf(index) >= 0) {\n        return false;\n      }\n      return true;\n    });\n  }\n  return res;\n}\n\n\nexport function filterReverseNonSameInterpretations(aSentences :  IMatch.IProcessedSentences ) : IMatch.IProcessedSentences {\n  var discardIndex = [] as Array<number>;\n  var res = (Object as any).assign( {}, aSentences );\n  res.sentences = aSentences.sentences.filter((sentence,index) => {\n    if(isNonOptimalDistinctSourceForSame(sentence, aSentences.sentences)) {\n      discardIndex.push(index);\n      return false;\n    }\n    return true;\n  });\n  if(discardIndex.length) {\n    res.errors = aSentences.errors.filter( (error,index) => {\n      if(discardIndex.indexOf(index) >= 0) {\n        return false;\n      }\n      return true;\n    });\n  }\n  return res;\n}\n\nexport function processString2(query: string, rules: IFModel.SplitRules,\n words: { [key: string]: Array<IMatch.ICategorizedString> }\n):  IMatch.IProcessedSentences {\n  words = words || {};\n  var tokenStruct = tokenizeString(query, rules, words);\n  debuglog(()=> `tokenized:\\n` + tokenStruct.categorizedWords.map( s => Sentence.simplifyStringsWithBitIndex(s).join(\"\\n\") ).join(\"\\n\"));\n  evaluateRangeRulesToPosition(tokenStruct.tokens, tokenStruct.fusable,\n    tokenStruct.categorizedWords);\n  debuglogV(()=>\"After matched \" + JSON.stringify(tokenStruct.categorizedWords));\n  var aSentences = expandTokenMatchesToSentences2(tokenStruct.tokens, tokenStruct.categorizedWords);\n  debuglog(() => \"after expand \" + aSentences.sentences.map(function (oSentence) {\n    return Sentence.rankingProduct(oSentence) + \":\\n\" + Sentence.dumpNiceBitIndexed(oSentence); //JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  var aSentences = filterNonSameInterpretations(aSentences);\n\n  aSentences = filterReverseNonSameInterpretations(aSentences);\n\n  aSentences.sentences = WordMatch.reinForce(aSentences.sentences);\n  debuglogV(()=> \"after reinforce\\n\" + aSentences.sentences.map(function (oSentence) {\n      return Sentence.rankingProduct(oSentence) + \":\\n\" + JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  debuglog(() => \"after reinforce\" + aSentences.sentences.map(function (oSentence) {\n    return Sentence.rankingProduct(oSentence) + \":\\n\" + Sentence.dumpNiceBitIndexed(oSentence); //JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  return aSentences;\n}\n\n\n"],"sourceRoot":"/source/"}