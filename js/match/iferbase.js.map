{"version":3,"sources":["../src/match/iferbase.ts"],"names":[],"mappings":";;AAIA,IAAkB,gBAIjB;AAJD,WAAkB,gBAAgB;IAChC,6DAAW,CAAA;IACX,uDAAI,CAAA;IACJ,yDAAK,CAAA;AACP,CAAC,EAJiB,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAIjC;AAGY,QAAA,YAAY,GAAG,UAAU,CAAC;AAC1B,QAAA,UAAU,GAAG,QAAQ,CAAC;AACtB,QAAA,QAAQ,GAAG,MAAM,CAAC;AAGlB,QAAA,iBAAiB,GAAG,eAAe,CAAC;AACpC,QAAA,eAAe,GAAG,aAAa,CAAC;AAK5C,CAAC;AAQD,CAAC;AAaW,QAAA,cAAc,GAAG,CAAC,eAAe,EAAE,aAAa,EAAE,YAAY,EAAE,WAAW,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AAgD5G,CAAC;AAWG,CAAC;AAkCL,CAAC;AAIuB,CAAC;AAgBzB,CAAC;AAoCD,CAAC;AAaD,CAAC;AA4BF,IAAkB,cAGjB;AAHD,WAAkB,cAAc;IAC9B,2DAAQ,CAAA;IACR,mEAAY,CAAA;AACd,CAAC,EAHiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAG/B","file":"match/iferbase.js","sourcesContent":["\n\nimport {IFModel  as IFModel} from 'mgnlq_model';\n\nexport const enum EnumResponseCode {\n  NOMATCH = 0,\n  EXEC,\n  QUERY\n}\n\n\nexport const CAT_CATEGORY = \"category\";\nexport const CAT_FILLER = \"filler\";\nexport const CAT_TOOL = \"tool\";\n\n\nexport const ERR_NO_KNOWN_WORD = \"NO_KNOWN_WORD\";\nexport const ERR_EMPTY_INPUT = \"EMPTY_INPUT\";\n\nexport interface IERError {\n  err_code : string,\n  text : string\n};\n\nexport interface IERErrorNO_KNOWN_WORD extends IERError{\n  context : {\n    token : string,\n    index: number,\n    tokens : string[]\n  }\n};\n\n\n\nexport interface IPromptDescription {\n  description: string,\n  type: string,\n  pattern: RegExp,\n  message: string,\n  default: string,\n  required: boolean\n}\n\nexport const aOperatorNames = [\"starting with\", \"ending with\", \"containing\", \"excluding\", \"having\", \"being\"];\nexport type OperatorName = \"starting with\" | \"ending with\" | \"containing\" | \"being\" | \"excluding\" | \"having\";\n\nexport interface IOperator {\n  operator : OperatorName,\n  code : string,\n  arity : number,\n  argcategory : [ string[] ]\n}\n\nexport type IRecord = { [key : string] : string\n};\n\n\nexport interface IWhatIsAnswer {\n  sentence: ISentence,\n  record : IRecord,\n  category : string,\n  result: string,\n  _ranking : number\n}\n\n\nexport interface IProcessedWhatIsAnswers extends IProcessed {\n  sentences? : ISentence[],\n  answers : IWhatIsAnswer[]\n}\n\n\n\nexport interface IProcessedWhatIsTupelAnswers extends IProcessed {\n  sentences? : ISentence[],\n  tupelanswers : Array<IWhatIsTupelAnswer>\n}\n\n\nexport interface IWhatIsTupelAnswer {\n  sentence: ISentence,\n  record : IRecord,\n  categories : string[],\n  result: string[],\n  _ranking : number\n}\n\n\nexport interface IMatchedSetRecord {\n  setId : string,\n  record : IRecord\n};\nexport type IMatchedSetRecords = IMatchedSetRecord[];\n/**\n * Map category -> value\n */\nexport type IMatchSet = { [key : string] : string};\n\n\nexport interface IToolSet {\n      set: string[],\n      response: string\n    };\n\n\nexport interface IToolMatchResult {\n  required: { [key: string]: IWord },\n  missing: { [key: string]: number },\n  optional?: { [key: string]: IWord },\n  spurious: { [key: string]: number },\n  toolmentioned: IWord[]\n}\n\nexport interface IPrompt {\n  text: string,\n  category: string\n}\n\n\nexport interface IWord {\n  string: string,\n  matchedString: string,\n  category: string,\n  _ranking?: number,\n  levenmatch?: number,\n  reinforce?: number,\n  bitindex? : number,\n  rule? : IFModel.mRule\n}\n\nexport type ISentence = Array<IWord>;\n\nexport type IRule = IFModel.IRule;\n\nexport interface IRange {\n  low: number, high: number,\n};\n\nexport interface IWordRange extends IRange\n{\n  rule? : IFModel.mRule };\n/**\n * A rule matching a single string\n */\n\n\nexport interface IWordRules {\n  rules : Array<IFModel.mRule>,\n  bitindex: number\n}\n\nexport interface SplitRules {\n  allRules: Array<IFModel.mRule>,\n  nonWordRules : Array<IFModel.mRule>,\n  wordMap: { [key : string] : IWordRules },\n  wordCache :  { [key: string]: Array<ICategorizedString> }\n};\n\nexport interface ICategorizedString {\n  string: string,\n  matchedString: string,\n  category: string,\n  breakdown?: Array<any>\n  score?: number,\n  _ranking?: number,\n  levenmatch?: number  // a distance ranking\n}\n\nexport interface ICategorizedStringRanged extends ICategorizedString{\n  string: string,\n  matchedString: string,\n  category: string,\n  breakdown?: Array<any>\n  /**\n   * Length of the entry (for skipping following words)\n   */\n  score?: number,\n  span? : number,\n  rule : IFModel.mRule,\n  _ranking?: number,\n  levenmatch?: number  // a distance ranking\n}\n\nexport interface IProcessed {\n  tokens : string[],\n  errors? : IERError[]\n}\n\nexport interface IProcessedSentences extends IProcessed {\n  tokens : string[],\n  errors? : any,\n  sentences : ISentence[]\n};\n\nexport type ICategoryFilter = { [key: string]: boolean };\n\n\nexport type IDomainCategoryFilter = {\n  domains : string[],\n  categorySet : { [key: string]: boolean }\n}\n\n\nexport interface IProcessedExtractedCategories extends IProcessed {\n  categories : string[],\n};\n\n\n\nexport type context = { [key: string]: string };\n\n/**\n * Defines the interface for an analysis\n * reponse\n */\nexport interface IResponse {\n  rating: number,\n  type: EnumResponseCode,\n  query: string,\n  context: { [key: string]: string },\n  text: string,\n  action: IAction,\n  prompts: {\n    [key: string]: {\n      text: string,\n      /**\n       * Follows the features of NPM prompts\n       */\n      description: IPromptDescription\n    };\n  }\n}\n\nexport const enum EnumActionType {\n  STARTURL,\n  STARTCMDLINE\n}\n\nexport interface IAction {\n  data: any,\n  type: EnumActionType,\n  pattern: string,\n  concrete: string\n}\n\n\nexport interface ICategoryDesc {\n  name: string,\n  importance? : number,\n  description? : string,\n  iskey? : boolean\n  exactMatch: boolean,\n  synonyms? : string[];\n}\n\n"],"sourceRoot":"/source/"}